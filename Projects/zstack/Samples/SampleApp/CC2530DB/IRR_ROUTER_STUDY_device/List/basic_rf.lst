###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         10/Dec/2014  17:47:05 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\Source\rssi_test\c\basic_rf.c  #
#    Command line       =  -f "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wRouter.cfg" (-DCPU32MHZ                  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=1         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=60            #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=30           #
#                          -DNWK_MAX_BINDING_ENTRIES=8                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 -DASSERT_RESET         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=8000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=1000)  #
#                          -DREJOIN_POLL_RATE=440 "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\Source #
#                          \rssi_test\c\basic_rf.c" -D NV_INIT -D NV_RESTORE  #
#                          -D HOLD_AUTO_START -D MT_TASK -D MT_APP_FUNC -D    #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D MT_ZDO_MGMT -D       #
#                          ISR_KEYINTERRUPT -D xWDT_IN_PM1 -D                 #
#                          xOSC32K_CRYSTAL_INSTALLED=0 -D xLARGER_NETWORK -D  #
#                          xPOWER_PA -D IRR_ROUTER -D HAVE_TEST_FUN -lC       #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\IRR_ROUTER_STUDY_dev #
#                          ice\List\" -lA "D:\RE_1_2_0_FORMAL_APP(251)-14-12- #
#                          8\Projects\zstack\Samples\SampleApp\CC2530DB\IRR_R #
#                          OUTER_STUDY_device\List\" --diag_suppress          #
#                          Pe001,Pa010 -o "D:\RE_1_2_0_FORMAL_APP(251)-14-12- #
#                          8\Projects\zstack\Samples\SampleApp\CC2530DB\IRR_R #
#                          OUTER_STUDY_device\Obj\" -e --no_cse --no_unroll   #
#                          --no_inline --no_code_motion --no_tbaa --debug     #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\Source\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\Source\rssi_t #
#                          est\h\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2530DB\..\Source #
#                          \IRR_router\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-1 #
#                          2-8\Projects\zstack\Samples\SampleApp\CC2530DB\..\ #
#                          ..\..\ZMain\TI2530DB\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\" -I "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\hal\target\CC2530EB\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\include\" -I                         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\high_level\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\single_chip\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mt\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8 #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\osal\include\" -I              #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\saddr\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\sdata\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\af\" -I "D:\RE_1_2_0_FORMAL_APP(251)-1 #
#                          4-12-8\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\..\..\..\..\Components\stack\nwk\" -I           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\" -I "D:\RE_1_2_0_FORMAL_APP(251) #
#                          -14-12-8\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\..\..\..\..\..\Components\stack\sec\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sys\" -I "D:\RE_1_2_0_FORMAL_APP(251)- #
#                          14-12-8\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\stack\zdo\" -I          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\zmac\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12 #
#                          -8\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\zmac\f8w\" -On               #
#                          --require_prototypes                               #
#    List file          =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\IRR_ROUTER_STUDY_devi #
#                          ce\List\basic_rf.lst                               #
#    Object file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\IRR_ROUTER_STUDY_devi #
#                          ce\Obj\basic_rf.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\rssi_test\c\basic_rf.c
      1          /***********************************************************************************
      2            Filename:     basic_rf.c
      3          
      4            Description:  Basic RF library
      5          
      6          ***********************************************************************************/
      7          
      8          /***********************************************************************************
      9          * INCLUDES
     10          */
     11          #include "int.h"
     12          #include "mcu.h"            // Using halMcuWaitUs()
     13          
     14          #include "rf.h"
     15          #ifdef SECURITY_CCM
     16          #include "rf_security.h"
     17          #endif
     18          
     19          #include "basic_rf.h"
     20          #ifdef SECURITY_CCM
     21          #include "basic_rf_security.h"
     22          #endif
     23          
     24          #include "util.h"               // Using min()
     25          #include "string.h"
     26          #include "comdef.h"
     27          
     28          /***********************************************************************************
     29          * CONSTANTS AND DEFINES
     30          */
     31          
     32          // Packet and packet part lengths
     33          #define PKT_LEN_MIC                         8
     34          #define PKT_LEN_SEC                         PKT_LEN_UNSEC + PKT_LEN_MIC
     35          #define PKT_LEN_AUTH                        8
     36          #define PKT_LEN_ENCR                        24
     37          
     38          // Packet overhead ((frame control field, sequence number, PAN ID,
     39          // destination and source) + (footer))
     40          // Note that the length byte itself is not included included in the packet length
     41          #define BASIC_RF_PACKET_OVERHEAD_SIZE       ((2 + 1 + 2 + 2 + 2) + (2))
     42          #define BASIC_RF_MAX_PAYLOAD_SIZE	        (127 - BASIC_RF_PACKET_OVERHEAD_SIZE - \
     43              BASIC_RF_AUX_HDR_LENGTH - BASIC_RF_LEN_MIC)
     44          #define BASIC_RF_ACK_PACKET_SIZE	        5
     45          #define BASIC_RF_FOOTER_SIZE                2
     46          #define BASIC_RF_HDR_SIZE                   10
     47          
     48          // The time it takes for the acknowledgment packet to be received after the
     49          // data packet has been transmitted.
     50          #define BASIC_RF_ACK_DURATION		        (0.5 * 32 * 2 * ((4 + 1) + (1) + (2 + 1) + (2)))
     51          #define BASIC_RF_SYMBOL_DURATION	        (32 * 0.5)
     52          
     53          // The length byte
     54          #define BASIC_RF_PLD_LEN_MASK               0x7F
     55          
     56          // Frame control field
     57          #define BASIC_RF_FCF_NOACK                  0x8841
     58          #define BASIC_RF_FCF_ACK                    0x8861
     59          #define BASIC_RF_FCF_ACK_BM                 0x0020
     60          #define BASIC_RF_FCF_BM                     (~BASIC_RF_FCF_ACK_BM)
     61          #define BASIC_RF_SEC_ENABLED_FCF_BM         0x0008
     62          
     63          // Frame control field LSB
     64          #define BASIC_RF_FCF_NOACK_L                LO_UINT16(BASIC_RF_FCF_NOACK)
     65          #define BASIC_RF_FCF_ACK_L                  LO_UINT16(BASIC_RF_FCF_ACK)
     66          #define BASIC_RF_FCF_ACK_BM_L               LO_UINT16(BASIC_RF_FCF_ACK_BM)
     67          #define BASIC_RF_FCF_BM_L                   LO_UINT16(BASIC_RF_FCF_BM)
     68          #define BASIC_RF_SEC_ENABLED_FCF_BM_L       LO_UINT16(BASIC_RF_SEC_ENABLED_FCF_BM)
     69          
     70          // Auxiliary Security header
     71          #define BASIC_RF_AUX_HDR_LENGTH             5
     72          #define BASIC_RF_LEN_AUTH                   BASIC_RF_PACKET_OVERHEAD_SIZE + \
     73              BASIC_RF_AUX_HDR_LENGTH - BASIC_RF_FOOTER_SIZE
     74          #define BASIC_RF_SECURITY_M                 2
     75          #define BASIC_RF_LEN_MIC                    8
     76          #ifdef SECURITY_CCM
     77          #undef BASIC_RF_HDR_SIZE
     78          #define BASIC_RF_HDR_SIZE                   15
     79          #endif
     80          
     81          // Footer
     82          #define BASIC_RF_CRC_OK_BM                  0x80
     83          
     84          /***********************************************************************************
     85          * TYPEDEFS
     86          */
     87          // The receive struct
     88          typedef struct {
     89              uint8 seqNumber;
     90              uint16 srcAddr;
     91              uint16 srcPanId;
     92              int8 length;
     93              uint8* pPayload;
     94              uint8 ackRequest;
     95              int8 rssi;
     96              volatile uint8 isReady;
     97              uint8 status;
     98          } basicRfRxInfo_t;
     99          
    100          // Tx state
    101          typedef struct {
    102              uint8 txSeqNumber;
    103              volatile uint8 ackReceived;
    104              uint8 receiveOn;
    105              uint32 frameCounter;
    106          } basicRfTxState_t;
    107          
    108          
    109          // Basic RF packet header (IEEE 802.15.4)
    110          typedef struct {
    111              uint8   packetLength;
    112              uint8   fcf0;           // Frame control field LSB
    113              uint8   fcf1;           // Frame control field MSB
    114              uint8   seqNumber;
    115              uint16  panId;
    116              uint16  destAddr;
    117              uint16  srcAddr;
    118              #ifdef SECURITY_CCM
    119              uint8   securityControl;
    120              uint8  frameCounter[4];
    121              #endif
    122          } basicRfPktHdr_t;
    123          
    124          
    125          /***********************************************************************************
    126          * LOCAL VARIABLES
    127          */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    128          static basicRfRxInfo_t  rxi=      { 0xFF }; // Make sure sequence numbers are
   \                     rxi:
   \   000000                DS 12
   \   00000C                REQUIRE `?<Initializer for rxi>`
   \   00000C                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    129          static basicRfTxState_t txState=  { 0x00 }; // initialised and distinct.
   \                     txState:
   \   000000                DS 7
   \   000007                REQUIRE __INIT_XDATA_Z
    130          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    131          static basicRfCfg_t* pConfig;
   \                     pConfig:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    132          static uint8 txMpdu[BASIC_RF_MAX_PAYLOAD_SIZE+BASIC_RF_PACKET_OVERHEAD_SIZE+1];
   \                     txMpdu:
   \   000000                DS 115
   \   000073                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    133          static uint8 rxMpdu[128];
   \                     rxMpdu:
   \   000000                DS 128
   \   000080                REQUIRE __INIT_XDATA_Z
    134          
    135          /***********************************************************************************
    136          * GLOBAL VARIABLES
    137          */
    138          
    139          
    140          /***********************************************************************************
    141          * LOCAL FUNCTIONS
    142          */
    143          
    144          
    145          /***********************************************************************************
    146          * @fn          basicRfBuildHeader
    147          *
    148          * @brief       Builds packet header according to IEEE 802.15.4 frame format
    149          *
    150          * @param       buffer - Pointer to buffer to write the header
    151          *              destAddr - destination short address
    152          *              payloadLength - length of higher layer payload
    153          *
    154          * @return      uint8 - length of header
    155          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    156          static uint8 basicRfBuildHeader(uint8* buffer, uint16 destAddr, uint8 payloadLength)
   \                     basicRfBuildHeader:
    157          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    158              basicRfPktHdr_t *pHdr;
    159              uint16 fcf;
    160          
    161              pHdr= (basicRfPktHdr_t*)buffer;
   \   000007   EA           MOV     A,R2
   \   000008   F8           MOV     R0,A
   \   000009   EB           MOV     A,R3
   \   00000A   F9           MOV     R1,A
   \   00000B   88..         MOV     ?V0 + 2,R0
   \   00000D   89..         MOV     ?V0 + 3,R1
    162          
    163              // Populate packet header
    164              pHdr->packetLength = payloadLength + BASIC_RF_PACKET_OVERHEAD_SIZE;
   \   00000F   740B         MOV     A,#0xb
   \   000011   25..         ADD     A,?V0 + 0
   \   000013   85..82       MOV     DPL,?V0 + 2
   \   000016   85..83       MOV     DPH,?V0 + 3
   \   000019   F0           MOVX    @DPTR,A
    165              //pHdr->frameControlField = pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
    166              fcf= pConfig->ackRequest ? BASIC_RF_FCF_ACK : BASIC_RF_FCF_NOACK;
   \   00001A   90....       MOV     DPTR,#pConfig
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F583         MOV     DPH,A
   \   000023   8882         MOV     DPL,R0
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   6006         JZ      ??basicRfBuildHeader_0
   \   00002D   7E61         MOV     R6,#0x61
   \   00002F   7F88         MOV     R7,#-0x78
   \   000031   8004         SJMP    ??basicRfBuildHeader_1
   \                     ??basicRfBuildHeader_0:
   \   000033   7E41         MOV     R6,#0x41
   \   000035   7F88         MOV     R7,#-0x78
    167              pHdr->fcf0 = LO_UINT16(fcf);
   \                     ??basicRfBuildHeader_1:
   \   000037   EE           MOV     A,R6
   \   000038   85..82       MOV     DPL,?V0 + 2
   \   00003B   85..83       MOV     DPH,?V0 + 3
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
    168              pHdr->fcf1 = HI_UINT16(fcf);
   \   000040   EE           MOV     A,R6
   \   000041   F8           MOV     R0,A
   \   000042   EF           MOV     A,R7
   \   000043   F9           MOV     R1,A
   \   000044   E4           CLR     A
   \   000045   E9           MOV     A,R1
   \   000046   F8           MOV     R0,A
   \   000047   85..82       MOV     DPL,?V0 + 2
   \   00004A   85..83       MOV     DPH,?V0 + 3
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   F0           MOVX    @DPTR,A
    169              pHdr->seqNumber= txState.txSeqNumber;
   \   000050   90....       MOV     DPTR,#txState
   \   000053   E0           MOVX    A,@DPTR
   \   000054   85..82       MOV     DPL,?V0 + 2
   \   000057   85..83       MOV     DPH,?V0 + 3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   F0           MOVX    @DPTR,A
    170              pHdr->panId= pConfig->panId;
   \   00005E   90....       MOV     DPTR,#pConfig
   \   000061   E0           MOVX    A,@DPTR
   \   000062   F8           MOV     R0,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F583         MOV     DPH,A
   \   000067   8882         MOV     DPL,R0
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   F8           MOV     R0,A
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F9           MOV     R1,A
   \   000070   85..82       MOV     DPL,?V0 + 2
   \   000073   85..83       MOV     DPH,?V0 + 3
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   E8           MOV     A,R0
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   E9           MOV     A,R1
   \   00007E   F0           MOVX    @DPTR,A
    171              pHdr->destAddr= destAddr;
   \   00007F   85..82       MOV     DPL,?V0 + 2
   \   000082   85..83       MOV     DPH,?V0 + 3
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   EC           MOV     A,R4
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   ED           MOV     A,R5
   \   00008F   F0           MOVX    @DPTR,A
    172              pHdr->srcAddr= pConfig->myAddr;
   \   000090   90....       MOV     DPTR,#pConfig
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F8           MOV     R0,A
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F583         MOV     DPH,A
   \   000099   8882         MOV     DPL,R0
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   F8           MOV     R0,A
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   F9           MOV     R1,A
   \   0000A0   85..82       MOV     DPL,?V0 + 2
   \   0000A3   85..83       MOV     DPH,?V0 + 3
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   E8           MOV     A,R0
   \   0000AF   F0           MOVX    @DPTR,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   E9           MOV     A,R1
   \   0000B2   F0           MOVX    @DPTR,A
    173          
    174              #ifdef SECURITY_CCM
    175          
    176              // Add security to FCF, length and security header
    177              pHdr->fcf0 |= BASIC_RF_SEC_ENABLED_FCF_BM_L;
    178              pHdr->packetLength += PKT_LEN_MIC;
    179              pHdr->packetLength += BASIC_RF_AUX_HDR_LENGTH;
    180          
    181              pHdr->securityControl= SECURITY_CONTROL;
    182              pHdr->frameCounter[0]=   LO_UINT16(LO_UINT32(txState.frameCounter));
    183              pHdr->frameCounter[1]=   HI_UINT16(LO_UINT32(txState.frameCounter));
    184              pHdr->frameCounter[2]=   LO_UINT16(HI_UINT32(txState.frameCounter));
    185              pHdr->frameCounter[3]=   HI_UINT16(HI_UINT32(txState.frameCounter));
    186          
    187              #endif
    188          
    189          
    190          
    191              return BASIC_RF_HDR_SIZE;
   \   0000B3   790A         MOV     R1,#0xa
   \   0000B5   7F04         MOV     R7,#0x4
   \   0000B7   02....       LJMP    ?BANKED_LEAVE_XDATA
    192          }
    193          
    194          
    195          /***********************************************************************************
    196          * @fn          basicRfBuildMpdu
    197          *
    198          * @brief       Builds mpdu (MAC header + payload) according to IEEE 802.15.4
    199          *              frame format
    200          *
    201          * @param       destAddr - Destination short address
    202          *              pPayload - pointer to buffer with payload
    203          *              payloadLength - length of payload buffer
    204          *
    205          * @return      uint8 - length of mpdu
    206          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    207          static uint8 basicRfBuildMpdu(uint16 destAddr, uint8* pPayload, uint8 payloadLength)
   \                     basicRfBuildMpdu:
    208          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   89..         MOV     ?V0 + 2,R1
    209              uint8 hdrLength, n;
    210          
    211              hdrLength = basicRfBuildHeader(txMpdu, destAddr, payloadLength);
   \   00000F                ; Setup parameters for call to function basicRfBuildHeader
   \   00000F   A9..         MOV     R1,?V0 + 2
   \   000011   AC..         MOV     R4,?V0 + 0
   \   000013   AD..         MOV     R5,?V0 + 1
   \   000015   7A..         MOV     R2,#txMpdu & 0xff
   \   000017   7B..         MOV     R3,#(txMpdu >> 8) & 0xff
   \   000019   12....       LCALL   ??basicRfBuildHeader?relay
   \   00001C   E9           MOV     A,R1
   \   00001D   F5..         MOV     ?V0 + 4,A
    212          
    213              for(n=0;n<payloadLength;n++)
   \   00001F   75..00       MOV     ?V0 + 3,#0x0
   \                     ??basicRfBuildMpdu_0:
   \   000022   E5..         MOV     A,?V0 + 3
   \   000024   C3           CLR     C
   \   000025   95..         SUBB    A,?V0 + 2
   \   000027   503A         JNC     ??basicRfBuildMpdu_1
    214              {
    215                  txMpdu[hdrLength+n] = pPayload[n];
   \   000029   85....       MOV     ?V0 + 6,?V0 + 3
   \   00002C   75..00       MOV     ?V0 + 7,#0x0
   \   00002F   EE           MOV     A,R6
   \   000030   25..         ADD     A,?V0 + 6
   \   000032   F582         MOV     DPL,A
   \   000034   EF           MOV     A,R7
   \   000035   35..         ADDC    A,?V0 + 7
   \   000037   F583         MOV     DPH,A
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   C0E0         PUSH    A
   \   00003C   85....       MOV     ?V0 + 8,?V0 + 4
   \   00003F   75..00       MOV     ?V0 + 9,#0x0
   \   000042   85....       MOV     ?V0 + 6,?V0 + 3
   \   000045   75..00       MOV     ?V0 + 7,#0x0
   \   000048   E5..         MOV     A,?V0 + 8
   \   00004A   25..         ADD     A,?V0 + 6
   \   00004C   F8           MOV     R0,A
   \   00004D   E5..         MOV     A,?V0 + 9
   \   00004F   35..         ADDC    A,?V0 + 7
   \   000051   F9           MOV     R1,A
   \   000052   74..         MOV     A,#txMpdu & 0xff
   \   000054   28           ADD     A,R0
   \   000055   F582         MOV     DPL,A
   \   000057   74..         MOV     A,#(txMpdu >> 8) & 0xff
   \   000059   39           ADDC    A,R1
   \   00005A   F583         MOV     DPH,A
   \   00005C   D0E0         POP     A
   \   00005E   F0           MOVX    @DPTR,A
    216              }
   \   00005F   05..         INC     ?V0 + 3
   \   000061   80BF         SJMP    ??basicRfBuildMpdu_0
    217              return hdrLength + payloadLength; // total mpdu length
   \                     ??basicRfBuildMpdu_1:
   \   000063   E5..         MOV     A,?V0 + 4
   \   000065   25..         ADD     A,?V0 + 2
   \   000067   F9           MOV     R1,A
   \   000068   7F0A         MOV     R7,#0xa
   \   00006A   02....       LJMP    ?BANKED_LEAVE_XDATA
    218          }
    219          
    220          
    221          /***********************************************************************************
    222          * @fn          basicRfRxFrmDoneIsr
    223          *
    224          * @brief       Interrupt service routine for received frame from radio
    225          *              (either data or acknowlegdement)
    226          *
    227          * @param       rxi - file scope variable info extracted from the last incoming
    228          *                    frame
    229          *              txState - file scope variable that keeps tx state info
    230          *
    231          * @return      none
    232          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    233          static void basicRfRxFrmDoneIsr(void)
   \                     basicRfRxFrmDoneIsr:
    234          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    235              basicRfPktHdr_t *pHdr;
    236              uint8 *pStatusWord;
    237              #ifdef SECURITY_CCM
    238              uint8 authStatus=0;
    239              #endif
    240          
    241              // Map header to packet buffer
    242              pHdr= (basicRfPktHdr_t*)rxMpdu;
   \   000005   7E..         MOV     R6,#rxMpdu & 0xff
   \   000007   7F..         MOV     R7,#(rxMpdu >> 8) & 0xff
    243          
    244              // Clear interrupt and disable new RX frame done interrupt
    245              halRfDisableRxInterrupt();
   \   000009                ; Setup parameters for call to function halRfDisableRxInterrupt
   \   000009   12....       LCALL   ??halRfDisableRxInterrupt?relay
    246          
    247              // Enable all other interrupt sources (enables interrupt nesting)
    248              halIntOn();
   \   00000C                ; Setup parameters for call to function halIntOn
   \   00000C   12....       LCALL   ??halIntOn?relay
    249          
    250              // Read payload length.
    251              halRfReadRxBuf(&pHdr->packetLength,1);
   \   00000F                ; Setup parameters for call to function halRfReadRxBuf
   \   00000F   7901         MOV     R1,#0x1
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??halRfReadRxBuf?relay
    252              pHdr->packetLength &= BASIC_RF_PLD_LEN_MASK; // Ignore MSB
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   C2E7         CLR     0xE0 /* A   */.7
   \   00001F   F0           MOVX    @DPTR,A
    253              
    254              // Is this an acknowledgment packet?
    255              // Only ack packets may be 5 bytes in total.
    256              if (pHdr->packetLength == BASIC_RF_ACK_PACKET_SIZE) {
   \   000020   8E82         MOV     DPL,R6
   \   000022   8F83         MOV     DPH,R7
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6405         XRL     A,#0x5
   \   000027   7056         JNZ     ??basicRfRxFrmDoneIsr_0
    257          
    258                  // Read the packet
    259                  halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
   \   000029                ; Setup parameters for call to function halRfReadRxBuf
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F9           MOV     R1,A
   \   00002F   7A..         MOV     R2,#(rxMpdu + 1) & 0xff
   \   000031   7B..         MOV     R3,#((rxMpdu + 1) >> 8) & 0xff
   \   000033   12....       LCALL   ??halRfReadRxBuf?relay
    260          
    261                  // Make sure byte fields are changed from network to host byte order
    262          
    263          
    264                  rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   A2E5         MOV     C,0xE0 /* A   */.5
   \   00003E   5004         JNC     ??basicRfRxFrmDoneIsr_1
   \   000040   D2F0         SETB    B.0
   \   000042   8002         SJMP    ??basicRfRxFrmDoneIsr_2
   \                     ??basicRfRxFrmDoneIsr_1:
   \   000044   C2F0         CLR     B.0
   \                     ??basicRfRxFrmDoneIsr_2:
   \   000046   A2F0         MOV     C,B.0
   \   000048   E4           CLR     A
   \   000049   33           RLC     A
   \   00004A   90....       MOV     DPTR,#rxi + 8
   \   00004D   F0           MOVX    @DPTR,A
    265          
    266                  // Read the status word and check for CRC OK
    267                  pStatusWord= rxMpdu + 4;
   \   00004E   75....       MOV     ?V0 + 0,#(rxMpdu + 4) & 0xff
   \   000051   75....       MOV     ?V0 + 1,#((rxMpdu + 4) >> 8) & 0xff
    268          
    269                  // Indicate the successful ACK reception if CRC and sequence number OK
    270                  if ((pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (pHdr->seqNumber == txState.txSeqNumber)) {
   \   000054   85..82       MOV     DPL,?V0 + 0
   \   000057   85..83       MOV     DPH,?V0 + 1
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   A2E7         MOV     C,0xE0 /* A   */.7
   \   00005E   4003         JC      $+5
   \   000060   02....       LJMP    ??basicRfRxFrmDoneIsr_3 & 0xFFFF
   \   000063   8E82         MOV     DPL,R6
   \   000065   8F83         MOV     DPH,R7
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   90....       MOV     DPTR,#txState
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   68           XRL     A,R0
   \   000071   6003         JZ      $+5
   \   000073   02....       LJMP    ??basicRfRxFrmDoneIsr_3 & 0xFFFF
    271                      txState.ackReceived = TRUE;
   \   000076   90....       MOV     DPTR,#txState + 1
   \   000079   7401         MOV     A,#0x1
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   02....       LJMP    ??basicRfRxFrmDoneIsr_3 & 0xFFFF
    272                  }
    273          
    274                  // No, it is data
    275              } else {
    276          
    277                  // It is assumed that the radio rejects packets with invalid length.
    278                  // Subtract the number of bytes in the frame overhead to get actual payload.
    279          
    280                  rxi.length = pHdr->packetLength - BASIC_RF_PACKET_OVERHEAD_SIZE;
   \                     ??basicRfRxFrmDoneIsr_0:
   \   00007F   8E82         MOV     DPL,R6
   \   000081   8F83         MOV     DPH,R7
   \   000083   E0           MOVX    A,@DPTR
   \   000084   24F5         ADD     A,#-0xb
   \   000086   90....       MOV     DPTR,#rxi + 5
   \   000089   F0           MOVX    @DPTR,A
    281          
    282                  #ifdef SECURITY_CCM
    283                  rxi.length -= (BASIC_RF_AUX_HDR_LENGTH + BASIC_RF_LEN_MIC);
    284                  authStatus = halRfReadRxBufSecure(&rxMpdu[1], pHdr->packetLength, rxi.length,
    285                                                  BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
    286                  #else
    287                  halRfReadRxBuf(&rxMpdu[1], pHdr->packetLength);
   \   00008A                ; Setup parameters for call to function halRfReadRxBuf
   \   00008A   8E82         MOV     DPL,R6
   \   00008C   8F83         MOV     DPH,R7
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   F9           MOV     R1,A
   \   000090   7A..         MOV     R2,#(rxMpdu + 1) & 0xff
   \   000092   7B..         MOV     R3,#((rxMpdu + 1) >> 8) & 0xff
   \   000094   12....       LCALL   ??halRfReadRxBuf?relay
    288                  #endif
    289          
    290          
    291          
    292                  rxi.ackRequest = !!(pHdr->fcf0 & BASIC_RF_FCF_ACK_BM_L);
   \   000097   8E82         MOV     DPL,R6
   \   000099   8F83         MOV     DPH,R7
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   A2E5         MOV     C,0xE0 /* A   */.5
   \   00009F   5004         JNC     ??basicRfRxFrmDoneIsr_4
   \   0000A1   D2F0         SETB    B.0
   \   0000A3   8002         SJMP    ??basicRfRxFrmDoneIsr_5
   \                     ??basicRfRxFrmDoneIsr_4:
   \   0000A5   C2F0         CLR     B.0
   \                     ??basicRfRxFrmDoneIsr_5:
   \   0000A7   A2F0         MOV     C,B.0
   \   0000A9   E4           CLR     A
   \   0000AA   33           RLC     A
   \   0000AB   90....       MOV     DPTR,#rxi + 8
   \   0000AE   F0           MOVX    @DPTR,A
    293          
    294                  // Read the source address
    295                  rxi.srcAddr= pHdr->srcAddr;
   \   0000AF   8E82         MOV     DPL,R6
   \   0000B1   8F83         MOV     DPH,R7
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F8           MOV     R0,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F9           MOV     R1,A
   \   0000C0   90....       MOV     DPTR,#rxi + 1
   \   0000C3   E8           MOV     A,R0
   \   0000C4   F0           MOVX    @DPTR,A
   \   0000C5   A3           INC     DPTR
   \   0000C6   E9           MOV     A,R1
   \   0000C7   F0           MOVX    @DPTR,A
    296          
    297                  // Read the packet payload
    298                  rxi.pPayload = rxMpdu + BASIC_RF_HDR_SIZE;
   \   0000C8   90....       MOV     DPTR,#rxi + 6
   \   0000CB   74..         MOV     A,#(rxMpdu + 10) & 0xff
   \   0000CD   F0           MOVX    @DPTR,A
   \   0000CE   A3           INC     DPTR
   \   0000CF   74..         MOV     A,#((rxMpdu + 10) >> 8) & 0xff
   \   0000D1   F0           MOVX    @DPTR,A
    299          
    300                  // Read the FCS to get the RSSI and CRC
    301                  pStatusWord= rxi.pPayload+rxi.length;
   \   0000D2   90....       MOV     DPTR,#rxi + 5
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   F8           MOV     R0,A
   \   0000D7   33           RLC     A
   \   0000D8   95E0         SUBB    A,0xE0 /* A   */
   \   0000DA   F9           MOV     R1,A
   \   0000DB   90....       MOV     DPTR,#rxi + 6
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   28           ADD     A,R0
   \   0000E0   F8           MOV     R0,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   39           ADDC    A,R1
   \   0000E4   F9           MOV     R1,A
   \   0000E5   88..         MOV     ?V0 + 0,R0
   \   0000E7   89..         MOV     ?V0 + 1,R1
    302                  #ifdef SECURITY_CCM
    303                  pStatusWord+= BASIC_RF_LEN_MIC;
    304                  #endif
    305                  rxi.rssi = pStatusWord[0];
   \   0000E9   85..82       MOV     DPL,?V0 + 0
   \   0000EC   85..83       MOV     DPH,?V0 + 1
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   90....       MOV     DPTR,#rxi + 9
   \   0000F3   F0           MOVX    @DPTR,A
    306          
    307                  // Notify the application about the received data packet if the CRC is OK
    308                  // Throw packet if the previous packet had the same sequence number
    309                  if( (pStatusWord[1] & BASIC_RF_CRC_OK_BM) && (rxi.seqNumber != pHdr->seqNumber) ) {
   \   0000F4   85..82       MOV     DPL,?V0 + 0
   \   0000F7   85..83       MOV     DPH,?V0 + 1
   \   0000FA   A3           INC     DPTR
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   A2E7         MOV     C,0xE0 /* A   */.7
   \   0000FE   502B         JNC     ??basicRfRxFrmDoneIsr_6
   \   000100   90....       MOV     DPTR,#rxi
   \   000103   E0           MOVX    A,@DPTR
   \   000104   F8           MOV     R0,A
   \   000105   8E82         MOV     DPL,R6
   \   000107   8F83         MOV     DPH,R7
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   68           XRL     A,R0
   \   00010E   601B         JZ      ??basicRfRxFrmDoneIsr_6
    310                      // If security is used check also that authentication passed
    311                      #ifdef SECURITY_CCM
    312                      if( authStatus==SUCCESS ) {
    313                          if ( (pHdr->fcf0 & BASIC_RF_FCF_BM_L) ==
    314                              (BASIC_RF_FCF_NOACK_L | BASIC_RF_SEC_ENABLED_FCF_BM_L)) {
    315                                  rxi.isReady = TRUE;
    316                          }
    317                      }
    318                      #else
    319                      if ( ((pHdr->fcf0 & (BASIC_RF_FCF_BM_L)) == BASIC_RF_FCF_NOACK_L) ) {
   \   000110   8E82         MOV     DPL,R6
   \   000112   8F83         MOV     DPH,R7
   \   000114   A3           INC     DPTR
   \   000115   E0           MOVX    A,@DPTR
   \   000116   F8           MOV     R0,A
   \   000117   7900         MOV     R1,#0x0
   \   000119   54DF         ANL     A,#0xdf
   \   00011B   F8           MOV     R0,A
   \   00011C   E9           MOV     A,R1
   \   00011D   5400         ANL     A,#0x0
   \   00011F   F9           MOV     R1,A
   \   000120   E8           MOV     A,R0
   \   000121   6441         XRL     A,#0x41
   \   000123   7006         JNZ     ??basicRfRxFrmDoneIsr_6
    320                          rxi.isReady = TRUE;
   \   000125   90....       MOV     DPTR,#rxi + 10
   \   000128   7401         MOV     A,#0x1
   \   00012A   F0           MOVX    @DPTR,A
    321                      }              
    322                      #endif
    323                  }
    324                  rxi.seqNumber = pHdr->seqNumber;
   \                     ??basicRfRxFrmDoneIsr_6:
   \   00012B   8E82         MOV     DPL,R6
   \   00012D   8F83         MOV     DPH,R7
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E0           MOVX    A,@DPTR
   \   000133   90....       MOV     DPTR,#rxi
   \   000136   F0           MOVX    @DPTR,A
    325              }
    326            
    327              // Enable RX frame done interrupt again
    328              halIntOff();
   \                     ??basicRfRxFrmDoneIsr_3:
   \   000137                ; Setup parameters for call to function halIntOff
   \   000137   12....       LCALL   ??halIntOff?relay
    329              halRfEnableRxInterrupt();
   \   00013A                ; Setup parameters for call to function halRfEnableRxInterrupt
   \   00013A   12....       LCALL   ??halRfEnableRxInterrupt?relay
    330          }
   \   00013D   7F02         MOV     R7,#0x2
   \   00013F   02....       LJMP    ?BANKED_LEAVE_XDATA
    331          
    332          
    333          /***********************************************************************************
    334          * GLOBAL FUNCTIONS
    335          */
    336          
    337          /***********************************************************************************
    338          * @fn          basicRfInit
    339          *
    340          * @brief       Initialise basic RF datastructures. Sets channel, short address and
    341          *              PAN id in the chip and configures interrupt on packet reception
    342          *
    343          * @param       pRfConfig - pointer to BASIC_RF_CONFIG struct.
    344          *                          This struct must be allocated by higher layer
    345          *              txState - file scope variable that keeps tx state info
    346          *              rxi - file scope variable info extracted from the last incoming
    347          *                    frame
    348          *
    349          * @return      none
    350          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          uint8 basicRfInit(basicRfCfg_t* pRfConfig)
   \                     basicRfInit:
    352          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    353              if (halRfInit()==FAILURE)
   \   000009                ; Setup parameters for call to function halRfInit
   \   000009   12....       LCALL   ??halRfInit?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7004         JNZ     ??basicRfInit_0
    354                  return FAILURE;
   \   000011   7901         MOV     R1,#0x1
   \   000013   806F         SJMP    ??basicRfInit_1
    355          
    356              halIntOff();
   \                     ??basicRfInit_0:
   \   000015                ; Setup parameters for call to function halIntOff
   \   000015   12....       LCALL   ??halIntOff?relay
    357          
    358              // Set the protocol configuration
    359              pConfig = pRfConfig;
   \   000018   90....       MOV     DPTR,#pConfig
   \   00001B   EE           MOV     A,R6
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   EF           MOV     A,R7
   \   00001F   F0           MOVX    @DPTR,A
    360              rxi.pPayload   = NULL;
   \   000020   90....       MOV     DPTR,#rxi + 6
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   7400         MOV     A,#0x0
   \   000029   F0           MOVX    @DPTR,A
    361          
    362              txState.receiveOn = TRUE;
   \   00002A   90....       MOV     DPTR,#txState + 2
   \   00002D   7401         MOV     A,#0x1
   \   00002F   F0           MOVX    @DPTR,A
    363              txState.frameCounter = 0;
   \   000030   90....       MOV     DPTR,#__Constant_0
   \   000033   12....       LCALL   ?XLOAD_R2345
   \   000036   90....       MOV     DPTR,#txState + 3
   \   000039   12....       LCALL   ?XSTORE_R2345
    364          
    365              // Set channel
    366              halRfSetChannel(pConfig->channel);
   \   00003C                ; Setup parameters for call to function halRfSetChannel
   \   00003C   90....       MOV     DPTR,#pConfig
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F8           MOV     R0,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F583         MOV     DPH,A
   \   000045   8882         MOV     DPL,R0
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F9           MOV     R1,A
   \   00004D   12....       LCALL   ??halRfSetChannel?relay
    367          
    368              // Write the short address and the PAN ID to the CC2520 RAM
    369              halRfSetShortAddr(pConfig->myAddr);
   \   000050                ; Setup parameters for call to function halRfSetShortAddr
   \   000050   90....       MOV     DPTR,#pConfig
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F583         MOV     DPH,A
   \   000059   8882         MOV     DPL,R0
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??halRfSetShortAddr?relay
    370              halRfSetPanId(pConfig->panId);
   \   000063                ; Setup parameters for call to function halRfSetPanId
   \   000063   90....       MOV     DPTR,#pConfig
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F8           MOV     R0,A
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   F583         MOV     DPH,A
   \   00006C   8882         MOV     DPL,R0
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FA           MOV     R2,A
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   FB           MOV     R3,A
   \   000075   12....       LCALL   ??halRfSetPanId?relay
    371          
    372              // if security is enabled, write key and nonce
    373              #ifdef SECURITY_CCM
    374              basicRfSecurityInit(pConfig);
    375              #endif
    376          
    377              // Set up receive interrupt (received data or acknowlegment)
    378              
    379              halRfRxInterruptConfig(basicRfRxFrmDoneIsr);
   \   000078                ; Setup parameters for call to function halRfRxInterruptConfig
   \   000078   7A..         MOV     R2,#??basicRfRxFrmDoneIsr?relay & 0xff
   \   00007A   7B..         MOV     R3,#(??basicRfRxFrmDoneIsr?relay >> 8) & 0xff
   \   00007C   12....       LCALL   ??halRfRxInterruptConfig?relay
    380          
    381              halIntOn();
   \   00007F                ; Setup parameters for call to function halIntOn
   \   00007F   12....       LCALL   ??halIntOn?relay
    382          
    383              return SUCCESS;
   \   000082   7900         MOV     R1,#0x0
   \                     ??basicRfInit_1:
   \   000084   7F01         MOV     R7,#0x1
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
    384          }
    385          
    386          
    387          /***********************************************************************************
    388          * @fn          basicRfSendPacket
    389          *
    390          * @brief       Send packet
    391          *
    392          * @param       destAddr - destination short address
    393          *              pPayload - pointer to payload buffer. This buffer must be
    394          *                         allocated by higher layer.
    395          *              length - length of payload
    396          *              txState - file scope variable that keeps tx state info
    397          *              mpdu - file scope variable. Buffer for the frame to send
    398          *
    399          * @return      basicRFStatus_t - SUCCESS or FAILED
    400          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    401          uint8 basicRfSendPacket(uint16 destAddr, uint8* pPayload, uint8 length)
   \                     basicRfSendPacket:
    402          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   89..         MOV     ?V0 + 0,R1
    403              uint8 mpduLength;
    404              uint8 status;
    405          
    406              // Turn on receiver if its not on
    407              if(!txState.receiveOn) {
   \   00000F   90....       MOV     DPTR,#txState + 2
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7003         JNZ     ??basicRfSendPacket_0
    408                  halRfReceiveOn();
   \   000015                ; Setup parameters for call to function halRfReceiveOn
   \   000015   12....       LCALL   ??halRfReceiveOn?relay
    409              }
    410          
    411              // Check packet length
    412              length = min(length, BASIC_RF_MAX_PAYLOAD_SIZE);
   \                     ??basicRfSendPacket_0:
   \   000018                ; Setup parameters for call to function min
   \   000018   7A67         MOV     R2,#0x67
   \   00001A   A9..         MOV     R1,?V0 + 0
   \   00001C   12....       LCALL   ??min?relay
   \   00001F   E9           MOV     A,R1
   \   000020   F5..         MOV     ?V0 + 0,A
    413          
    414              // Wait until the transceiver is idle
    415              halRfWaitTransceiverReady();
   \   000022                ; Setup parameters for call to function halRfWaitTransceiverReady
   \   000022   12....       LCALL   ??halRfWaitTransceiverReady?relay
    416          
    417              // Turn off RX frame done interrupt to avoid interference on the SPI interface
    418              halRfDisableRxInterrupt();
   \   000025                ; Setup parameters for call to function halRfDisableRxInterrupt
   \   000025   12....       LCALL   ??halRfDisableRxInterrupt?relay
    419          
    420              mpduLength = basicRfBuildMpdu(destAddr, pPayload, length);
   \   000028                ; Setup parameters for call to function basicRfBuildMpdu
   \   000028   A9..         MOV     R1,?V0 + 0
   \   00002A   EE           MOV     A,R6
   \   00002B   FC           MOV     R4,A
   \   00002C   EF           MOV     A,R7
   \   00002D   FD           MOV     R5,A
   \   00002E   AA..         MOV     R2,?V0 + 4
   \   000030   AB..         MOV     R3,?V0 + 5
   \   000032   12....       LCALL   ??basicRfBuildMpdu?relay
   \   000035   E9           MOV     A,R1
   \   000036   F5..         MOV     ?V0 + 1,A
    421          
    422              #ifdef SECURITY_CCM
    423              halRfWriteTxBufSecure(txMpdu, mpduLength, length, BASIC_RF_LEN_AUTH, BASIC_RF_SECURITY_M);
    424              txState.frameCounter++;     // Increment frame counter field
    425              #else
    426              halRfWriteTxBuf(txMpdu, mpduLength);
   \   000038                ; Setup parameters for call to function halRfWriteTxBuf
   \   000038   A9..         MOV     R1,?V0 + 1
   \   00003A   7A..         MOV     R2,#txMpdu & 0xff
   \   00003C   7B..         MOV     R3,#(txMpdu >> 8) & 0xff
   \   00003E   12....       LCALL   ??halRfWriteTxBuf?relay
    427              #endif
    428          
    429              // Turn on RX frame done interrupt for ACK reception
    430              halRfEnableRxInterrupt();
   \   000041                ; Setup parameters for call to function halRfEnableRxInterrupt
   \   000041   12....       LCALL   ??halRfEnableRxInterrupt?relay
    431          
    432              // Send frame with CCA. return FAILED if not successful
    433              if(halRfTransmit() != SUCCESS) {
   \   000044                ; Setup parameters for call to function halRfTransmit
   \   000044   12....       LCALL   ??halRfTransmit?relay
   \   000047   E9           MOV     A,R1
   \   000048   6003         JZ      ??basicRfSendPacket_1
    434                  status = FAILURE;
   \   00004A   75..01       MOV     ?V0 + 2,#0x1
    435              }
    436          
    437              // Wait for the acknowledge to be received, if any
    438              if (pConfig->ackRequest) {
   \                     ??basicRfSendPacket_1:
   \   00004D   90....       MOV     DPTR,#pConfig
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F8           MOV     R0,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F583         MOV     DPH,A
   \   000056   8882         MOV     DPL,R0
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   601D         JZ      ??basicRfSendPacket_2
    439                  txState.ackReceived = FALSE;
   \   000060   90....       MOV     DPTR,#txState + 1
   \   000063   7400         MOV     A,#0x0
   \   000065   F0           MOVX    @DPTR,A
    440          
    441                  // We'll enter RX automatically, so just wait until we can be sure that the ack reception should have finished
    442                  // The timeout consists of a 12-symbol turnaround time, the ack packet duration, and a small margin
    443                  halMcuWaitUs((12 * BASIC_RF_SYMBOL_DURATION) + (BASIC_RF_ACK_DURATION) + (2 * BASIC_RF_SYMBOL_DURATION) + 10);
   \   000066                ; Setup parameters for call to function halMcuWaitUs
   \   000066   7A4A         MOV     R2,#0x4a
   \   000068   7B02         MOV     R3,#0x2
   \   00006A   12....       LCALL   ??halMcuWaitUs?relay
    444          
    445                  // If an acknowledgment has been received (by RxFrmDoneIsr), the ackReceived flag should be set
    446                  status = txState.ackReceived ? SUCCESS : FAILURE;
   \   00006D   90....       MOV     DPTR,#txState + 1
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6004         JZ      ??basicRfSendPacket_3
   \   000073   7400         MOV     A,#0x0
   \   000075   8002         SJMP    ??basicRfSendPacket_4
   \                     ??basicRfSendPacket_3:
   \   000077   7401         MOV     A,#0x1
   \                     ??basicRfSendPacket_4:
   \   000079   F5..         MOV     ?V0 + 2,A
   \   00007B   8003         SJMP    ??basicRfSendPacket_5
    447          
    448              } else {
    449                  status = SUCCESS;
   \                     ??basicRfSendPacket_2:
   \   00007D   75..00       MOV     ?V0 + 2,#0x0
    450              }
    451          
    452              // Turn off the receiver if it should not continue to be enabled
    453              if (!txState.receiveOn) {
   \                     ??basicRfSendPacket_5:
   \   000080   90....       MOV     DPTR,#txState + 2
   \   000083   E0           MOVX    A,@DPTR
   \   000084   7003         JNZ     ??basicRfSendPacket_6
    454                  halRfReceiveOff();
   \   000086                ; Setup parameters for call to function halRfReceiveOff
   \   000086   12....       LCALL   ??halRfReceiveOff?relay
    455              }
    456          
    457              if(status == SUCCESS) {
   \                     ??basicRfSendPacket_6:
   \   000089   E5..         MOV     A,?V0 + 2
   \   00008B   7007         JNZ     ??basicRfSendPacket_7
    458                  txState.txSeqNumber++;
   \   00008D   90....       MOV     DPTR,#txState
   \   000090   E0           MOVX    A,@DPTR
   \   000091   2401         ADD     A,#0x1
   \   000093   F0           MOVX    @DPTR,A
    459              }
    460          
    461          #ifdef SECURITY_CCM
    462              halRfIncNonceTx();          // Increment nonce value
    463          #endif
    464          
    465              return status;
   \                     ??basicRfSendPacket_7:
   \   000094   A9..         MOV     R1,?V0 + 2
   \   000096   7F06         MOV     R7,#0x6
   \   000098   02....       LJMP    ?BANKED_LEAVE_XDATA
    466          
    467          }
    468          
    469          
    470          /***********************************************************************************
    471          * @fn          basicRfPacketIsReady
    472          *
    473          * @brief       Check if a new packet is ready to be read by next higher layer
    474          *
    475          * @param       none
    476          *
    477          * @return      uint8 - TRUE if a packet is ready to be read by higher layer
    478          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    479          uint8 basicRfPacketIsReady(void)
   \                     basicRfPacketIsReady:
    480          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    481              return rxi.isReady;
   \   000004   90....       MOV     DPTR,#rxi + 10
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   02....       LJMP    ?BRET
    482          }
    483          
    484          
    485          /**********************************************************************************
    486          * @fn          basicRfReceive
    487          *
    488          * @brief       Copies the payload of the last incoming packet into a buffer
    489          *
    490          * @param       pRxData - pointer to data buffer to fill. This buffer must be
    491          *                        allocated by higher layer.
    492          *              len - Number of bytes to read in to buffer
    493          *              rxi - file scope variable holding the information of the last
    494          *                    incoming packet
    495          *
    496          * @return      uint8 - number of bytes actually copied into buffer
    497          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    498          uint8 basicRfReceive(uint8* pRxData, uint8 len, int16* pRssi)
   \                     basicRfReceive:
    499          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 2,R1
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
    500              // Accessing shared variables -> this is a critical region
    501              // Critical region start
    502              halIntOff();
   \   00000F                ; Setup parameters for call to function halIntOff
   \   00000F   12....       LCALL   ??halIntOff?relay
    503              memcpy(pRxData, rxi.pPayload, min(rxi.length, len));
   \   000012                ; Setup parameters for call to function min
   \   000012   AA..         MOV     R2,?V0 + 2
   \   000014   90....       MOV     DPTR,#rxi + 5
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   12....       LCALL   ??min?relay
   \   00001C   E9           MOV     A,R1
   \   00001D   F5..         MOV     ?V0 + 4,A
   \   00001F                ; Setup parameters for call to function memcpy
   \   00001F   75..00       MOV     ?V0 + 5,#0x0
   \   000022   78..         MOV     R0,#?V0 + 4
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   90....       MOV     DPTR,#rxi + 6
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   FC           MOV     R4,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FD           MOV     R5,A
   \   00002F   EE           MOV     A,R6
   \   000030   FA           MOV     R2,A
   \   000031   EF           MOV     A,R7
   \   000032   FB           MOV     R3,A
   \   000033   12....       LCALL   ??memcpy?relay
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?DEALLOC_XSTACK8
    504              if(pRssi != NULL) {
   \   00003B   E5..         MOV     A,?V0 + 0
   \   00003D   45..         ORL     A,?V0 + 1
   \   00003F   6026         JZ      ??basicRfReceive_0
    505                  if(rxi.rssi < 128){
                                     ^
Warning[Pa084]: pointless integer comparison, the result is always true
    506                      *pRssi = rxi.rssi - halRfGetRssiOffset();
   \   000041                ; Setup parameters for call to function halRfGetRssiOffset
   \   000041   12....       LCALL   ??halRfGetRssiOffset?relay
   \   000044   E9           MOV     A,R1
   \   000045   F5..         MOV     ?V0 + 4,A
   \   000047   90....       MOV     DPTR,#rxi + 9
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F8           MOV     R0,A
   \   00004C   33           RLC     A
   \   00004D   95E0         SUBB    A,0xE0 /* A   */
   \   00004F   F9           MOV     R1,A
   \   000050   75..00       MOV     ?V0 + 5,#0x0
   \   000053   E8           MOV     A,R0
   \   000054   C3           CLR     C
   \   000055   95..         SUBB    A,?V0 + 4
   \   000057   F8           MOV     R0,A
   \   000058   E9           MOV     A,R1
   \   000059   95..         SUBB    A,?V0 + 5
   \   00005B   F9           MOV     R1,A
   \   00005C   85..82       MOV     DPL,?V0 + 0
   \   00005F   85..83       MOV     DPH,?V0 + 1
   \   000062   E8           MOV     A,R0
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   E9           MOV     A,R1
   \   000066   F0           MOVX    @DPTR,A
    507                  }
    508                  else{
    509                      *pRssi = (rxi.rssi - 256) - halRfGetRssiOffset();
    510                  }
    511              }
    512              rxi.isReady = FALSE;
   \                     ??basicRfReceive_0:
   \   000067   90....       MOV     DPTR,#rxi + 10
   \   00006A   7400         MOV     A,#0x0
   \   00006C   F0           MOVX    @DPTR,A
    513              halIntOn();
   \   00006D                ; Setup parameters for call to function halIntOn
   \   00006D   12....       LCALL   ??halIntOn?relay
    514          
    515              // Critical region end
    516          
    517              return min(rxi.length, len);
   \   000070                ; Setup parameters for call to function min
   \   000070   AA..         MOV     R2,?V0 + 2
   \   000072   90....       MOV     DPTR,#rxi + 5
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F9           MOV     R1,A
   \   000077   12....       LCALL   ??min?relay
   \   00007A   7F06         MOV     R7,#0x6
   \   00007C   02....       LJMP    ?BANKED_LEAVE_XDATA
    518          }
    519          
    520          
    521          /**********************************************************************************
    522          * @fn          basicRfGetRssi
    523          *
    524          * @brief       Copies the payload of the last incoming packet into a buffer
    525          *
    526          * @param       none
    527          
    528          * @return      int8 - RSSI value
    529          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    530          int8 basicRfGetRssi(void)
   \                     basicRfGetRssi:
    531          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    532              if(rxi.rssi < 128){
                                 ^
Warning[Pa084]: pointless integer comparison, the result is always true
    533                  return rxi.rssi - halRfGetRssiOffset();
   \   000004                ; Setup parameters for call to function halRfGetRssiOffset
   \   000004   12....       LCALL   ??halRfGetRssiOffset?relay
   \   000007   E9           MOV     A,R1
   \   000008   F8           MOV     R0,A
   \   000009   90....       MOV     DPTR,#rxi + 9
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   F9           MOV     R1,A
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
    534              }
    535              else{
    536                  return (rxi.rssi - 256) - halRfGetRssiOffset();
    537              }
    538          }
    539          
    540          /***********************************************************************************
    541          * @fn          basicRfReceiveOn
    542          *
    543          * @brief       Turns on receiver on radio
    544          *
    545          * @param       txState - file scope variable
    546          *
    547          * @return      none
    548          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    549          void basicRfReceiveOn(void)
   \                     basicRfReceiveOn:
    550          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    551              txState.receiveOn = TRUE;
   \   000004   90....       MOV     DPTR,#txState + 2
   \   000007   7401         MOV     A,#0x1
   \   000009   F0           MOVX    @DPTR,A
    552              halRfReceiveOn();
   \   00000A                ; Setup parameters for call to function halRfReceiveOn
   \   00000A   12....       LCALL   ??halRfReceiveOn?relay
    553          }
   \   00000D   D083         POP     DPH
   \   00000F   D082         POP     DPL
   \   000011   02....       LJMP    ?BRET
    554          
    555          
    556          /***********************************************************************************
    557          * @fn          basicRfReceiveOff
    558          *
    559          * @brief       Turns off receiver on radio
    560          *
    561          * @param       txState - file scope variable
    562          *
    563          * @return      none
    564          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    565          void basicRfReceiveOff(void)
   \                     basicRfReceiveOff:
    566          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    567              txState.receiveOn = FALSE;
   \   000004   90....       MOV     DPTR,#txState + 2
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    568              halRfReceiveOff();
   \   00000A                ; Setup parameters for call to function halRfReceiveOff
   \   00000A   12....       LCALL   ??halRfReceiveOff?relay
    569          }
   \   00000D   D083         POP     DPH
   \   00000F   D082         POP     DPL
   \   000011   02....       LJMP    ?BRET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for rxi>`:
   \   000000   FF           DB 255
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   000000       DB 0, 0, 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfBuildHeader?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfBuildHeader

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfBuildMpdu?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfBuildMpdu

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfRxFrmDoneIsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfRxFrmDoneIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfSendPacket?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfSendPacket

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfPacketIsReady?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfPacketIsReady

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfReceive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfReceive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfGetRssi?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfGetRssi

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfReceiveOn?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfReceiveOn

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??basicRfReceiveOff?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    basicRfReceiveOff
    570          
    571          
    572          /***********************************************************************************
    573            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
    574          
    575            IMPORTANT: Your use of this Software is limited to those specific rights
    576            granted under the terms of a software license agreement between the user
    577            who downloaded the software, his/her employer (which must be your employer)
    578            and Texas Instruments Incorporated (the "License").  You may not use this
    579            Software unless you agree to abide by the terms of the License. The License
    580            limits your use, and you acknowledge, that the Software may not be modified,
    581            copied or distributed unless embedded on a Texas Instruments microcontroller
    582            or used solely and exclusively in conjunction with a Texas Instruments radio
    583            frequency transceiver, which is integrated into your product.  Other than for
    584            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    585            works of, modify, distribute, perform, display or sell this Software and/or
    586            its documentation for any purpose.
    587          
    588            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    589            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    590            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    591            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    592            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    593            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    594            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
    595            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
    596            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
    597            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    598            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    599          
    600            Should you have any questions regarding your right to use this Software,
    601            contact Texas Instruments Incorporated at www.TI.com.
    602          ***********************************************************************************/
    603          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     basicRfBuildHeader                 1      0     30
     basicRfBuildMpdu                   1      0     32
       -> basicRfBuildHeader            0      0     36
     basicRfGetRssi                     2      0      0
       -> halRfGetRssiOffset            4      0      0
     basicRfInit                        0      0      9
       -> halRfInit                     0      0     18
       -> halIntOff                     0      0     18
       -> halRfSetChannel               0      0     18
       -> halRfSetShortAddr             0      0     18
       -> halRfSetPanId                 0      0     18
       -> halRfRxInterruptConfig        0      0     18
       -> halIntOn                      0      0     18
     basicRfPacketIsReady               2      0      0
     basicRfReceive                     0      0     16
       -> halIntOff                     0      0     28
       -> min                           0      0     28
       -> memcpy                        0      0     32
       -> halRfGetRssiOffset            0      0     28
       -> halIntOn                      0      0     28
       -> min                           0      0     28
     basicRfReceiveOff                  2      0      0
       -> halRfReceiveOff               4      0      0
     basicRfReceiveOn                   2      0      0
       -> halRfReceiveOn                4      0      0
     basicRfRxFrmDoneIsr                0      0     10
       -> halRfDisableRxInterrupt       0      0     20
       -> halIntOn                      0      0     20
       -> halRfReadRxBuf                0      0     20
       -> halRfReadRxBuf                0      0     20
       -> halRfReadRxBuf                0      0     20
       -> halIntOff                     0      0     20
       -> halRfEnableRxInterrupt        0      0     20
     basicRfSendPacket                  0      0     14
       -> halRfReceiveOn                0      0     28
       -> min                           0      0     28
       -> halRfWaitTransceiverReady     0      0     28
       -> halRfDisableRxInterrupt       0      0     28
       -> basicRfBuildMpdu              0      0     28
       -> halRfWriteTxBuf               0      0     28
       -> halRfEnableRxInterrupt        0      0     28
       -> halRfTransmit                 0      0     28
       -> halMcuWaitUs                  0      0     28
       -> halRfReceiveOff               0      0     28


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     rxi                            12
     txState                         7
     pConfig                         2
     txMpdu                        115
     rxMpdu                        128
     basicRfBuildHeader            186
     basicRfBuildMpdu              109
     basicRfRxFrmDoneIsr           322
     basicRfInit                   137
     basicRfSendPacket             155
     basicRfPacketIsReady           16
     basicRfReceive                127
     basicRfGetRssi                 23
     basicRfReceiveOn               20
     basicRfReceiveOff              20
     ?<Initializer for rxi>         12
     __Constant_0                    4
     ??basicRfBuildHeader?relay      6
     ??basicRfBuildMpdu?relay        6
     ??basicRfRxFrmDoneIsr?relay     6
     ??basicRfInit?relay             6
     ??basicRfSendPacket?relay       6
     ??basicRfPacketIsReady?relay    6
     ??basicRfReceive?relay          6
     ??basicRfGetRssi?relay          6
     ??basicRfReceiveOn?relay        6
     ??basicRfReceiveOff?relay       6

 
 1 115 bytes in segment BANKED_CODE
    60 bytes in segment BANK_RELAYS
    12 bytes in segment XDATA_I
    12 bytes in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
   252 bytes in segment XDATA_Z
 
 1 187 bytes of CODE  memory
     0 bytes of CONST memory (+ 4 bytes shared)
   264 bytes of XDATA memory

Errors: none
Warnings: 2
