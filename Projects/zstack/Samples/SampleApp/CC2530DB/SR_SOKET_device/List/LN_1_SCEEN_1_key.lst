###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         08/Feb/2015  18:10:57 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_ #
#                          1_SCEEN_1_key.c                                    #
#    Command line       =  -f "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wRouter.cfg" (-DCPU32MHZ                  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=1         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=60            #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=30           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=4 -DASSERT_RESET         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=8000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=1000)  #
#                          -DREJOIN_POLL_RATE=440 "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\Source #
#                          \LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c" -D        #
#                          NV_INIT -D NV_RESTORE -D HOLD_AUTO_START -D        #
#                          MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D           #
#                          MT_ZDO_FUNC -D MT_ZDO_MGMT -D ISR_KEYINTERRUPT -D  #
#                          xWDT_IN_PM1 -D xOSC32K_CRYSTAL_INSTALLED=0 -D      #
#                          xLARGER_NETWORK -D xPOWER_PA -D SR_SOKET -lC       #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SR_SOKET_device\List #
#                          \" -lA "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projec #
#                          ts\zstack\Samples\SampleApp\CC2530DB\SR_SOKET_devi #
#                          ce\List\" --diag_suppress Pe001,Pa010 -o           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SR_SOKET_device\Obj\ #
#                          " -e --no_cse --no_unroll --no_inline              #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\Source\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMain\T #
#                          I2530DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\hal\include\" -I                #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\target\CC2530EB\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\include\" -I "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\mac\high_level\" -I   #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\single_chip\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mt\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8 #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\osal\include\" -I              #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\saddr\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\sdata\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\af\" -I "D:\RE_1_2_0_FORMAL_APP(251)-1 #
#                          4-12-8\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\..\..\..\..\Components\stack\nwk\" -I           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\" -I "D:\RE_1_2_0_FORMAL_APP(251) #
#                          -14-12-8\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\..\..\..\..\..\Components\stack\sec\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sys\" -I "D:\RE_1_2_0_FORMAL_APP(251)- #
#                          14-12-8\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\stack\zdo\" -I          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\zmac\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12 #
#                          -8\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\zmac\f8w\" -On               #
#                          --require_prototypes                               #
#    List file          =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SR_SOKET_device\List\ #
#                          LN_1_SCEEN_1_key.lst                               #
#    Object file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SR_SOKET_device\Obj\L #
#                          N_1_SCEEN_1_key.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          /*
     84          #include "hal_mcu.h"
     85          #include "hal_defs.h"
     86          #include "hal_types.h"
     87          #include "hal_board.h"
     88          #include "hal_drivers.h"
     89          #include "hal_adc.h"
     90          #include "hal_key.h"
     91          #include "osal.h"
     92          #include "hal_led.h"
     93          #include "ZDApp.h"
     94          #include "device.h"
     95          #include "IO_config.h"
     96          //#include "ZDO_LIB.h"
     97          #include "ZDObject.h"
     98          #include "common_device.h"
     99          */
    100          
    101          #include "hal_mcu.h"
    102          #include "hal_defs.h"
    103          #include "hal_types.h"
    104          #include "hal_board.h"
    105          #include "hal_drivers.h"
    106          #include "hal_adc.h"
    107          #include "hal_key.h"
    108          #include "osal.h"
    109          #include "IO_config.h"
    110          #include "common_device.h"
    111          #include "device.h"
    112          #include "ZDObject.h"
    113          
    114          
    115          
    116          
    117          extern void Delay_1u(uint32 microSecs); 
    118          
    119            extern uint8 zdoDiscCounter;
    120          
    121          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    122          
    123          /**************************************************************************************************
    124           *                                              MACROS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                            CONSTANTS
    129           **************************************************************************************************/
    130          #define HAL_KEY_RISING_EDGE   0
    131          #define HAL_KEY_FALLING_EDGE  1
    132          
    133          #define HAL_KEY_DEBOUNCE_VALUE  50
    134          #define HAL_KEY_CLICKED_VALUE  600  //600ms 内没按键中断则按键检测结束，发送检测到的按键次数到应用层
    135          #define HAL_KEY_HOLD_VALUE  9400    //9.4s  按键长按10s（9.4s+600ms）以后判断为长按按钮操作
    136          #define HAL_KEY_DOBULETICK_VALUE   1000
    137          /* CPU port interrupt */
    138          #define HAL_KEY_CPU_PORT_0_IF P0IF
    139          #define HAL_KEY_CPU_PORT_1_IF P1IF
    140          #define HAL_KEY_CPU_PORT_2_IF P2IF
    141          
    142          /* SW_6 is at P1.2 */
    143          #define HAL_KEY_SW_6_PORT   P1
    144          #define HAL_KEY_SW_6_BIT    BV(3)
    145          #define HAL_KEY_SW_6_SEL    P1SEL
    146          #define HAL_KEY_SW_6_DIR    P1DIR
    147          /* edge interrupt */
    148          #define HAL_KEY_SW_6_EDGEBIT  BV(1)
    149          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    150          /* SW_6 interrupts */
    151          #define HAL_KEY_SW_6_IEN      IEN2  /* CPU interrupt mask register */
    152          #define HAL_KEY_SW_6_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    153          #define HAL_KEY_SW_6_ICTL     P1IEN /* Port Interrupt Control register */
    154          #define HAL_KEY_SW_6_ICTLBIT  BV(3) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    155          #define HAL_KEY_SW_6_PXIFG    P1IFG /* Interrupt flag at source */
    156          
    157          
    158          /* SW_6 is at P1.2 */
    159          #define HAL_KEY_SW_7_PORT   P1
    160          #define HAL_KEY_SW_7_BIT    BV(1)
    161          #define HAL_KEY_SW_7_SEL    P1SEL
    162          #define HAL_KEY_SW_7_DIR    P1DIR
    163          /* edge interrupt */
    164          #define HAL_KEY_SW_7_EDGEBIT  BV(1)
    165          #define HAL_KEY_SW_7_EDGE     HAL_KEY_FALLING_EDGE
    166          /* SW_6 interrupts */
    167          #define HAL_KEY_SW_7_IEN      IEN2  /* CPU interrupt mask register */
    168          #define HAL_KEY_SW_7_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    169          #define HAL_KEY_SW_7_ICTL     P1IEN /* Port Interrupt Control register */
    170          #define HAL_KEY_SW_7_ICTLBIT  BV(1) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    171          #define HAL_KEY_SW_7_PXIFG    P1IFG /* Interrupt flag at source */
    172          
    173          
    174          /* SW_8 is at P1.3 */
    175          #define HAL_KEY_SW_9_PORT   P1
    176          #define HAL_KEY_SW_9_BIT    BV(2)
    177          #define HAL_KEY_SW_9_SEL    P1SEL
    178          #define HAL_KEY_SW_9_DIR    P1DIR
    179          /* edge interrupt */
    180          #define HAL_KEY_SW_9_EDGEBIT  BV(1)//p1端口的触发模式设置 在PICTL的低第二位（位1）
    181          #define HAL_KEY_SW_9_EDGE     HAL_KEY_FALLING_EDGE  // 
    182          /* SW_8 interrupts */
    183          #define HAL_KEY_SW_9_IEN      IEN2  /* CPU interrupt mask register */
    184          #define HAL_KEY_SW_9_IENBIT   BV(4) /* Mask bit for all of Port_1 */
    185          #define HAL_KEY_SW_9_ICTL     P1IEN /* Port Interrupt Control register */
    186          #define HAL_KEY_SW_9_ICTLBIT  BV(2) /* P1IEN - P1.2 enable/disable bit */ 
    187          #define HAL_KEY_SW_9_PXIFG    P1IFG /* Interrupt flag at source */
    188          
    189          
    190          /* SW_9 is at P1.4 */
    191          #define HAL_KEY_SW_8_PORT   P1
    192          #define HAL_KEY_SW_8_BIT    BV(7)
    193          #define HAL_KEY_SW_8_SEL    P1SEL
    194          #define HAL_KEY_SW_8_DIR    P1DIR
    195          /* edge interrupt */
    196          #define HAL_KEY_SW_8_EDGEBIT  BV(2)//p1端口的触发模式设置 在PICTL的低第三位（位2）P1.5为高4位地址
    197          #define HAL_KEY_SW_8_EDGE     HAL_KEY_FALLING_EDGE  // 
    198          /* SW_9 interrupts */
    199          #define HAL_KEY_SW_8_IEN      IEN2  /* CPU interrupt mask register */
    200          #define HAL_KEY_SW_8_IENBIT   BV(4) /* Mask bit for all of Port_1 */
    201          #define HAL_KEY_SW_8_ICTL     P1IEN /* Port Interrupt Control register */
    202          #define HAL_KEY_SW_8_ICTLBIT  BV(7) /* P1IEN - P1.4 enable/disable bit */ 
    203          #define HAL_KEY_SW_8_PXIFG    P1IFG /* Interrupt flag at source */
    204          
    205          
    206          
    207          
    208          #define KEY_FORBITON_TIME   300
    209          
    210          /**************************************************************************************************
    211           *                                            TYPEDEFS
    212           **************************************************************************************************/
    213          
    214          
    215          /**************************************************************************************************
    216           *                                        GLOBAL VARIABLES
    217           **************************************************************************************************/
    218          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
    219           halKeyCBack_t pHalKeyProcessFunction;
    220          static uint8 HalKeyConfigured;
    221          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
    222          
    223          /**************************************************************************************************
    224           *                                        FUNCTIONS - Local
    225           **************************************************************************************************/
    226          void halProcessKeyInterrupt(void);
    227          uint8 halGetJoyKeyInput(void);
    228          uint8 kpush0=0;
    229          uint8 kpush1=0;
    230          uint8 key_ISR_FLAG=0;
    231          uint8 KEY_NET_ISR_FLAG=0;//test p1.2口的单击 双击
    232          uint8 key_double_flag = 0;//按键双击状态
    233          
    234          uint8 key_holdtime_waiting_flag = 0;//等待长按时间（10s）标志 ，0无等待 1正在等待
    235          
    236          uint8 key_hold_flag = 0;  //按键长按标志
    237          
    238          uint8 Forbitten_ON_flag=0;
    239          
    240          uint8 KEY_NUMBER_FLAG_A = 0;//按键标志
    241          
    242          
    243          
    244          /**************************************************************************************************
    245           *                                        FUNCTIONS - API
    246           **************************************************************************************************/
    247          
    248          
    249          /**************************************************************************************************
    250           * @fn      HalKeyInit
    251           *
    252           * @brief   Initilize Key Service
    253           *
    254           * @param   none
    255           *
    256           * @return  None
    257           **************************************************************************************************/
    258          void HalKeyInit( void )
    259          {
    260            /* Initialize previous key to 0 */
    261            halKeySavedKeys = 0;
    262            
    263            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    264            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    265            
    266            HAL_KEY_SW_7_SEL &= ~(HAL_KEY_SW_7_BIT);    /* Set pin function to GPIO */
    267            HAL_KEY_SW_7_DIR &= ~(HAL_KEY_SW_7_BIT);    /* Set pin direction to Input */
    268            
    269            HAL_KEY_SW_8_SEL &= ~(HAL_KEY_SW_8_BIT);    /* Set pin function to GPIO */
    270            HAL_KEY_SW_8_DIR &= ~(HAL_KEY_SW_8_BIT);    /* Set pin direction to Input */
    271            
    272            HAL_KEY_SW_9_SEL &= ~(HAL_KEY_SW_9_BIT);    /* Set pin function to GPIO */
    273            HAL_KEY_SW_9_DIR &= ~(HAL_KEY_SW_9_BIT);    /* Set pin direction to Input */
    274          
    275          
    276            /* Initialize callback function */
    277            pHalKeyProcessFunction  = NULL;
    278          
    279            /* Start with key is not configured */
    280            HalKeyConfigured = FALSE;
    281          }
    282          
    283          
    284          /**************************************************************************************************
    285           * @fn      HalKeyConfig
    286           *
    287           * @brief   Configure the Key serivce
    288           *
    289           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    290           *          cback - pointer to the CallBack function
    291           *
    292           * @return  None
    293           **************************************************************************************************/
    294          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
    295          {
    296            /* Enable/Disable Interrupt or */
    297            Hal_KeyIntEnable = interruptEnable;
    298          
    299            /* Register the callback fucntion */
    300            pHalKeyProcessFunction = cback;
    301          
    302            /* Determine if interrupt is enable or not */
    303            if (Hal_KeyIntEnable)
    304            {
    305                /* Rising/Falling edge configuratinn */
    306          
    307             
    308              //P1.2  
    309              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
    310              /* For falling edge, the bit must be set. */
    311            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    312              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    313            #endif
    314          
    315          
    316              /* Interrupt configuration:
    317               * - Enable interrupt generation at the port
    318               * - Enable CPU interrupt
    319               * - Clear any pending interrupt
    320               */
    321             // HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
    322              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;//使能整个CPU的P0口中断
    323              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);//清中断标记位
    324            
    325              
    326              //P1.5
    327              PICTL &= ~(HAL_KEY_SW_7_EDGEBIT);    /* Clear the edge bit */
    328              /* For falling edge, the bit must be set. */
    329            #if (HAL_KEY_SW_7_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    330              PICTL |= HAL_KEY_SW_7_EDGEBIT;
    331            #endif
    332          
    333              /* Interrupt configuration:
    334               * - Enable interrupt generation at the port
    335               * - Enable CPU interrupt
    336               * - Clear any pending interrupt
    337               */
    338              HAL_KEY_SW_7_ICTL |= HAL_KEY_SW_7_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
    339              HAL_KEY_SW_7_IEN |= HAL_KEY_SW_7_IENBIT;//使能整个CPU的P0口中断
    340              HAL_KEY_SW_7_PXIFG = ~(HAL_KEY_SW_7_BIT);//清中断标记位
    341              
    342              
    343              
    344              //P1.6
    345               PICTL &= ~(HAL_KEY_SW_8_EDGEBIT);    /* Clear the edge bit */
    346              /* For falling edge, the bit must be set. */
    347            #if (HAL_KEY_SW_8_EDGE == HAL_KEY_FALLING_EDGE)
    348              PICTL |= HAL_KEY_SW_8_EDGEBIT;			//P1.0~p1.3下降沿 。p1.2 按键下降沿
    349            #endif
    350          
    351              /* Interrupt configuration:
    352               * - Enable interrupt generation at the port
    353               * - Enable CPU interrupt
    354               * - Clear any pending interrupt
    355               */
    356              HAL_KEY_SW_8_ICTL |= HAL_KEY_SW_8_ICTLBIT;//P1IEN | 00000100  即P1.2使能中断
    357              HAL_KEY_SW_8_IEN |= HAL_KEY_SW_8_IENBIT;//使能整个CPU的P1口中断
    358              HAL_KEY_SW_8_PXIFG &= ~(HAL_KEY_SW_8_BIT);//清中断标记位
    359             
    360              
    361          
    362          //P1.7
    363               PICTL &= ~(HAL_KEY_SW_9_EDGEBIT);    /* Clear the edge bit */
    364              /* For falling edge, the bit must be set. */
    365            #if (HAL_KEY_SW_9_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    366              PICTL |= HAL_KEY_SW_9_EDGEBIT;
    367            #endif
    368          
    369              HAL_KEY_SW_9_ICTL |= HAL_KEY_SW_9_ICTLBIT;//P1IEN | 00100000  即P1.5使能中断
    370              HAL_KEY_SW_9_IEN |= HAL_KEY_SW_9_IENBIT;//使能整个CPU的P1口中断
    371              HAL_KEY_SW_9_PXIFG = ~(HAL_KEY_SW_9_BIT);//清中断标记位
    372              
    373          
    374              /* Do this only after the hal_key is configured - to work with sleep stuff */
    375              if (HalKeyConfigured == TRUE)
    376              {
    377                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
    378              }
    379            }
    380            else    /* Interrupts NOT enabled */
    381            {
    382              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt */
    383              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
    384          
    385              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
    386            }
    387          
    388            /* Key now is configured */
    389            HalKeyConfigured = TRUE;
    390          }
    391          
    392          
    393          /**************************************************************************************************
    394           * @fn      HalKeyRead
    395           *
    396           * @brief   Read the current value of a key
    397           *
    398           * @param   None
    399           *
    400           * @return  keys - current keys status
    401           **************************************************************************************************/
    402          uint8 HalKeyRead ( void )
    403          {
    404            uint8 keys = 0;
    405          
    406            if (HAL_PUSH_BUTTON1())
    407            {
    408              keys |= HAL_KEY_SW_6;
    409            }
    410          
    411            
    412          
    413            return keys;
    414          }
    415          
    416          
    417          /**************************************************************************************************
    418           * @fn      HalKeyPoll
    419           *
    420           * @brief   Called by hal_driver to poll the keys
    421           *
    422           * @param   None
    423           *
    424           * @return  None
    425          
    426          对应关系：
    427          P1.2 HAL_PUSH_BUTTON3 左边第一个按键 HAL_KEY_SW_8_PXIFG   HAL_KEY_SW_8 对应左边第一个灯 LED1 P1.0 key_other2_present_flag
    428          P1.5 HAL_PUSH_BUTTON2 中间按键      HAL_KEY_SW_7_PXIFG   HAL_KEY_SW_7 对应左边中间灯  LED2    P0.6 key_other3_present_flag
    429          P1.6 HAL_PUSH_BUTTON1 右边最后一个按键      HAL_KEY_SW_6_PXIFG   HAL_KEY_SW_6 对应右边灯  LED3 P0.5 key_other4_present_flag
    430          P1.7 HAL_PUSH_BUTTON5 系统内置按键      HAL_KEY_SW_9_PXIFG   HAL_KEY_SW_9 对应右边灯  LED5     P2.0 key_other1_present_flag
    431          
    432          
    433            
    434          
    435           **************************************************************************************************/
    436          void HalKeyPoll (void)
    437          {
    438           uint8 keys = 0;
    439          
    440            
    441          
    442            /* If interrupts are not enabled, previous key status and current key status
    443             * are compared to find out if a key has changed status.
    444             */
    445            if (!Hal_KeyIntEnable)
    446            {
    447              if (keys == halKeySavedKeys)
    448              {
    449                 /* Exit - since no keys have changed */
    450                return;
    451              }
    452              /* Store the current keys for comparation next time */
    453              halKeySavedKeys = keys;
    454            }
    455            else
    456            {
    457              /* Key interrupt handled here */
    458          
    459              
    460              //P1.7 单跷板  为系统设置按钮 对应的指示灯位 P2.0
    461                if ((key_ISR_FLAG==HAL_KEY_SW_8) && (!(HAL_PUSH_BUTTON3())))//初步理解，设置p1.2为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
    462             {
    463               
    464               
    465               if(key_holdtime_waiting_flag)
    466          	 {
    467          	   key_holdtime_waiting_flag = 0;//在等待长按时间时再次按下按钮 此时需要清等待长按时间标志以及取消之前设置的等待长按时间满以后进入事件
    468          	   osal_stop_timerEx (Hal_TaskID, HAL_KEY_HOLD_EVENT);//  停止之前进入的事件
    469          	   KEY_NET_ISR_FLAG = 0;// 等待长按时间被打断后 重新计数按键次数
    470          	 }
    471               
    472               KEY_NET_ISR_FLAG++;//test 测试单击 双击等程序
    473               osal_stop_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT);//  停止之前进入的事件
    474               osal_start_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT, HAL_KEY_CLICKED_VALUE);//600mS后触发检测几击程序
    475             } 
    476              
    477              // P1.2 单翘班 对应第一个左边的按钮 灯为LED1 
    478             else if ((key_ISR_FLAG==HAL_KEY_SW_9) && (!HAL_PUSH_BUTTON5()))//初步理解，设置p1.5为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
    479             {
    480                 
    481               P1IEN &= ~BV(2);
    482               osal_stop_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_1);
                                         ^
Error[Pe020]: identifier "UserApp_TaskID" is undefined

       osal_stop_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_1);
                                          ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",482  Error[Pe020]: 
          identifier "HAL_KEY_INTERRUPT_STOP_1" is undefined
    483               osal_start_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_1, KEY_FORBITON_TIME);
    484                
    485                if(!(HAL_PUSH_BUTTON3()))//P1.7按下
    486               {
    487               SampleApp_send_in_binding_req(SAMPLEAPP_ENDPOINT1,bindingINClusters,1);
                                                                        ^
Error[Pe020]: identifier "bindingINClusters" is undefined
    488               }
    489                else
    490               {
    491                 if ( (load_1_flag == 0) &&(Forbitten_ON_flag==0))
                              ^
Error[Pe020]: identifier "load_1_flag" is undefined
    492                  {
    493                     open_load_1();
                            ^
Error[Pe223]: function "open_load_1" declared implicitly
    494                     osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_1_EVT,RELAY_HOLD_TIME );   
                                                               ^
Error[Pe020]: identifier "HOLD_LOAD_1_EVT" is undefined

             osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_1_EVT,RELAY_HOLD_TIME );   
                                                                ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",494  Error[Pe020]: 
          identifier "RELAY_HOLD_TIME" is undefined
    495                   } 
    496                   
    497                  else
    498                   {
    499                     close_load_1();
                            ^
Error[Pe223]: function "close_load_1" declared implicitly
    500                     osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_1_EVT,RELAY_HOLD_TIME );   
                                                               ^
Error[Pe020]: identifier "HOLD_LOAD_1_EVT" is undefined

             osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_1_EVT,RELAY_HOLD_TIME );   
                                                                ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",500  Error[Pe020]: 
          identifier "RELAY_HOLD_TIME" is undefined
    501                   } 
    502                  
    503                if( (devState==DEV_END_DEVICE) || (devState==DEV_ROUTER) )
    504                   {
    505                      SampleApp_SendInMessage();
    506                   }
    507                }
    508             }
    509             
    510             // P1.5 对应中间的按钮 指示灯也是中间的 
    511            else  if ((key_ISR_FLAG==HAL_KEY_SW_7) && (!HAL_PUSH_BUTTON2()))//初步理解，设置p1.5为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
    512             {
    513               
    514                P1IEN &= ~BV(1);//p1.1 
    515                osal_stop_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_2);//  停止之前进入的事件
                                          ^
Error[Pe020]: identifier "UserApp_TaskID" is undefined

        osal_stop_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_2);//  停止之前进入的事件
                                           ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",515  Error[Pe020]: 
          identifier "HAL_KEY_INTERRUPT_STOP_2" is undefined
    516                osal_start_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_2, KEY_FORBITON_TIME);
    517               
    518               //  if((MONZ_2 == 1)&&(load_2_flag ==0))//检测是否在线的信号，如果接了灯 灯是关的 这个值为高电平 如果灯是开的为低电平 如果没有接等也为低电平 所以要判断这个值是否为高才能去控制他开，不然会浪费功耗。
    519                
    520               if(!(HAL_PUSH_BUTTON3()))//P1.7按下
    521               {
    522                 SampleApp_send_in_binding_req(SAMPLEAPP_ENDPOINT2,bindingINClusters,1);
                                                      ^
Error[Pe020]: identifier "SAMPLEAPP_ENDPOINT2" is undefined

         SampleApp_send_in_binding_req(SAMPLEAPP_ENDPOINT2,bindingINClusters,1);
                                                           ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",522  Error[Pe020]: 
          identifier "bindingINClusters" is undefined
    523               }
    524                else
    525               {
    526                     if ( (load_2_flag == 0) &&(Forbitten_ON_flag==0))
                                  ^
Error[Pe020]: identifier "load_2_flag" is undefined
    527                {
    528                   open_load_2();
                          ^
Error[Pe223]: function "open_load_2" declared implicitly
    529                   osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_2_EVT,RELAY_HOLD_TIME );   
                                                             ^
Error[Pe020]: identifier "HOLD_LOAD_2_EVT" is undefined

           osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_2_EVT,RELAY_HOLD_TIME );   
                                                              ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",529  Error[Pe020]: 
          identifier "RELAY_HOLD_TIME" is undefined
    530                 } 
    531                 
    532                else
    533                 {
    534                  close_load_2();
                         ^
Error[Pe223]: function "close_load_2" declared implicitly
    535                  osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_2_EVT,RELAY_HOLD_TIME );       
                                                            ^
Error[Pe020]: identifier "HOLD_LOAD_2_EVT" is undefined

          osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_2_EVT,RELAY_HOLD_TIME );       
                                                             ^
"D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_1_SCEEN_1_device\LN_1_SCEEN_1_key.c",535  Error[Pe020]: 
          identifier "RELAY_HOLD_TIME" is undefined
    536                 } 
    537             
    538          
    539             if( (devState==DEV_END_DEVICE) || (devState==DEV_ROUTER) )
    540                 {
    541                    SampleApp_SendInMessage();
    542                 }
    543               }
    544             }
    545             
    546            
    547             /*
    548                 //P1.6 对应第三个按钮 最右边的 对应指示灯LED3 P0.5
    549            else if ((key_ISR_FLAG==HAL_KEY_SW_6) && (!(HAL_PUSH_BUTTON1())))//初步理解，设置p1.2为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
    550             {
    551                P1IEN &= ~BV(3);
    552                osal_stop_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_3);//  停止之前进入的事件
    553                osal_start_timerEx (UserApp_TaskID, HAL_KEY_INTERRUPT_STOP_3, KEY_FORBITON_TIME);
    554               
    555               //  if((MONZ_2 == 1)&&(load_2_flag ==0))//检测是否在线的信号，如果接了灯 灯是关的 这个值为高电平 如果灯是开的为低电平 如果没有接等也为低电平 所以要判断这个值是否为高才能去控制他开，不然会浪费功耗。
    556               
    557                 if(!(HAL_PUSH_BUTTON3()))//P1.7按下
    558               {
    559                SampleApp_send_in_binding_req(SAMPLEAPP_ENDPOINT3,bindingINClusters,1);
    560               }
    561                else
    562               {
    563               
    564                if ( (load_3_flag == 0) &&( (zdoDiscCounter==20)|| (zdoDiscCounter==1)) )
    565                {
    566                   open_load_3();
    567                   osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_3_EVT,RELAY_HOLD_TIME );   
    568                 } 
    569                 
    570                else
    571                 {
    572                  close_load_3();
    573                  osal_start_timerEx( UserApp_TaskID,HOLD_LOAD_3_EVT,RELAY_HOLD_TIME );      
    574                 } 
    575               
    576                if( (devState==DEV_END_DEVICE) || (devState==DEV_ROUTER) )
    577                 {
    578                    SampleApp_SendInMessage();
    579                 } 
    580              }
    581             }
    582          */
    583            }
    584          
    585            
    586          
    587           
    588            /* Invoke Callback if new keys were depressed */
    589            if (keys && (pHalKeyProcessFunction))
    590            {
    591              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
    592              key_ISR_FLAG=0;
    593            }
    594          }
    595          
    596          
    597          
    598          
    599          /**************************************************************************************************
    600           * @fn      halGetJoyKeyInput
    601           *
    602           * @brief   Map the ADC value to its corresponding key.
    603           *
    604           * @param   None
    605           *
    606           * @return  keys - current joy key status
    607           **************************************************************************************************/
    608          uint8 halGetJoyKeyInput(void)
    609          {
    610            /* The joystick control is encoded as an analog voltage.
    611             * Read the JOY_LEVEL analog value and map it to joy movement.
    612             */
    613            uint8 adc;
                         ^
Warning[Pe177]: variable "adc" was declared but never referenced
    614            uint8 ksave0 = 0;
    615            uint8 ksave1;
                         ^
Warning[Pe177]: variable "ksave1" was declared but never referenced
    616          
    617          
    618          
    619            return ksave0;
    620          }
    621          
    622          
    623          
    624          
    625          
    626          /**************************************************************************************************
    627           * @fn      halProcessKeyInterrupt
    628           *
    629           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    630           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    631           *
    632           * @param
    633           *
    634           * @return
    635           **************************************************************************************************/
    636          void halProcessKeyInterrupt (void)
    637          {
    638            bool valid=FALSE;
    639            
    640          
    641            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
    642            {
    643              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
    644              valid = TRUE;
    645            }
    646          
    647              if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)  /* Interrupt Flag has been set */
    648            {
    649              HAL_KEY_SW_7_PXIFG = ~(HAL_KEY_SW_7_BIT); /* Clear Interrupt Flag */
    650              valid = TRUE;
    651          
    652            }
    653            
    654              if (HAL_KEY_SW_8_PXIFG & HAL_KEY_SW_8_BIT)  /* Interrupt Flag has been set */
    655            {
    656              HAL_KEY_SW_8_PXIFG = ~(HAL_KEY_SW_8_BIT); /* Clear Interrupt Flag */
                                          ^
Warning[Pe069]: integer conversion resulted in truncation
    657              valid = TRUE;
    658          
    659            }
    660            
    661              if (HAL_KEY_SW_9_PXIFG & HAL_KEY_SW_9_BIT)  /* Interrupt Flag has been set */
    662            {
    663              HAL_KEY_SW_9_PXIFG = ~(HAL_KEY_SW_9_BIT); /* Clear Interrupt Flag */
    664              valid = TRUE;
    665          
    666           }
    667            
    668            
    669          
    670          
    671            if (valid)
    672           {
    673              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
    674            }
    675          }
    676          
    677          /**************************************************************************************************
    678           * @fn      HalKeyEnterSleep
    679           *
    680           * @brief  - Get called to enter sleep mode
    681           *
    682           * @param
    683           *
    684           * @return
    685           **************************************************************************************************/
    686          void HalKeyEnterSleep ( void )
    687          {
    688          }
    689          
    690          /**************************************************************************************************
    691           * @fn      HalKeyExitSleep
    692           *
    693           * @brief   - Get called when sleep is over
    694           *
    695           * @param
    696           *
    697           * @return  - return saved keys
    698           **************************************************************************************************/
    699          uint8 HalKeyExitSleep ( void )
    700          {
    701            /* Wake up and read keys */
    702            return ( HalKeyRead () );
    703          }
    704          
    705          /***************************************************************************************************
    706           *                                    INTERRUPT SERVICE ROUTINE
    707           ***************************************************************************************************/
    708          
    709          /**************************************************************************************************
    710           * @fn      halKeyPort0Isr
    711           *
    712           * @brief   Port0 ISR
    713           *
    714           * @param
    715           *
    716           * @return
    717           **************************************************************************************************/
    718          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    719          {
    720            HAL_ENTER_ISR();
    721          
    722            CLEAR_SLEEP_MODE();
    723            HAL_EXIT_ISR();
    724          }
    725          
    726          
    727          /**************************************************************************************************
    728           * @fn      halKeyPort1Isr
    729           *
    730           * @brief   Port1 ISR
    731           *
    732           * @param
    733           *
    734           * @return
    735           **************************************************************************************************/
    736          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
    737          {
    738            HAL_ENTER_ISR();
    739            //uint8 keys=0;
    740          uint8 P1IEN_FLAG_1=0,P1IEN_FLAG_2=0,P1IEN_FLAG_3=0;
                       ^
Warning[Pe177]: variable "P1IEN_FLAG_1" was declared but never referenced
    741            
    742          /*
    743          
    744             if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
    745            {
    746                  P1IEN_FLAG_1 = P1IEN & 0X08;//p1.3
    747               if(P1IEN_FLAG_1==0X08)
    748              {
    749              key_ISR_FLAG =HAL_KEY_SW_6;
    750              halProcessKeyInterrupt();
    751              HAL_KEY_SW_6_PXIFG = 0;
    752              }
    753             }
    754             */
    755            
    756              if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)
    757            {
    758              
    759               P1IEN_FLAG_2 = P1IEN & 0X02;//p1.1
    760               if(P1IEN_FLAG_2==0X02)
    761              {
    762                halProcessKeyInterrupt();
    763                HAL_KEY_SW_7_PXIFG = 0;
    764                key_ISR_FLAG =HAL_KEY_SW_7;
    765              }
    766            }
    767          
    768             if(HAL_KEY_SW_9_PXIFG & HAL_KEY_SW_9_BIT)//p1.2中断标志
    769            {
    770              
    771               P1IEN_FLAG_3 = P1IEN & 0X04;//p1.2
    772               if(P1IEN_FLAG_3==0X04)
    773              {
    774               halProcessKeyInterrupt();
    775               HAL_KEY_SW_9_PXIFG = 0;//清除p1.2标志
    776               key_ISR_FLAG =HAL_KEY_SW_9;
    777              }
    778           
    779            }
    780            
    781               if(HAL_KEY_SW_8_PXIFG & HAL_KEY_SW_8_BIT)//p1.7中断标志
    782            {
    783              
    784               halProcessKeyInterrupt();
    785               HAL_KEY_SW_8_PXIFG = 0;//清除p1.2标志
    786               key_ISR_FLAG =HAL_KEY_SW_8;
    787           
    788            }
    789            
    790            /*
    791              Clear the CPU interrupt flag for Port_1
    792              PxIFG has to be cleared before PxIF
    793            */
    794            HAL_KEY_CPU_PORT_1_IF = 0;
    795           // PCON = 0x00;//唤醒
    796            
    797            CLEAR_SLEEP_MODE();
    798            HAL_EXIT_ISR();
    799            
    800          }
    801          
    802          
    803          
    804          
    805          /**************************************************************************************************
    806           * @fn      halKeyPort2Isr
    807           *
    808           * @brief   Port2 ISR
    809           *
    810           * @param
    811           *
    812           * @return
    813           **************************************************************************************************/
    814          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    815          {
    816          
    817          }
    818          
    819          
    820          
    821          
    822          #else
    823          
    824          void Key_Check(void){}
    825          void HalKeyInit(void){}
    826          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    827          uint8 HalKeyRead(void){ return 0;}
    828          void HalKeyPoll(void){}
    829          void HalKey_double_detect(void);
    830          #endif /* HAL_KEY */
    831          
    832          
    833          
    834          
    835          
    836          /**************************************************************************************************
    837          **************************************************************************************************/
    838          
    839          
    840          

Errors: 21
Warnings: 4
