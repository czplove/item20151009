###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         11/Dec/2014  16:16:20 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\Source\rssi_test\c\util_buffer #
#                          .c                                                 #
#    Command line       =  -f "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wEndev.cfg" (-DCPU32MHZ                   #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=1         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=60            #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=30           #
#                          -DNWK_MAX_BINDING_ENTRIES=1                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 -DASSERT_RESET         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=8000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=1000)  #
#                          -DREJOIN_POLL_RATE=440 "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\Source #
#                          \rssi_test\c\util_buffer.c" -D NV_INIT -D          #
#                          NV_RESTORE -D HOLD_AUTO_START -D MT_TASK -D        #
#                          xMT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D      #
#                          xMT_ZDO_MGMT -D ISR_KEYINTERRUPT -D POWER_SAVING   #
#                          -D LONG_POLL_TIMES -D HAVE_TEST_FUN -D             #
#                          RESUME_TIME_TEST -D SCEEN_KEYPAD -D M_V332 -lC     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\List\"  #
#                          -lA "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Lis #
#                          t\" --diag_suppress Pe001,Pa010 -o                 #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Obj\"   #
#                          -e --no_cse --no_unroll --no_inline                #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\Source\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\Source\rssi_t #
#                          est\h\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2530DB\..\Source #
#                          \SCEEN_KEYPAD\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14 #
#                          -12-8\Projects\zstack\Samples\SampleApp\CC2530DB\. #
#                          .\..\..\ZMain\TI2530DB\" -I                        #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\" -I "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\hal\target\CC2530EB\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\include\" -I                         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\high_level\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\single_chip\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mt\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8 #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\osal\include\" -I              #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\saddr\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\sdata\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\af\" -I "D:\RE_1_2_0_FORMAL_APP(251)-1 #
#                          4-12-8\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\..\..\..\..\Components\stack\nwk\" -I           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\" -I "D:\RE_1_2_0_FORMAL_APP(251) #
#                          -14-12-8\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\..\..\..\..\..\Components\stack\sec\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sys\" -I "D:\RE_1_2_0_FORMAL_APP(251)- #
#                          14-12-8\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\stack\zdo\" -I          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\zmac\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12 #
#                          -8\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\zmac\f8w\" -On               #
#                          --require_prototypes                               #
#    List file          =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\List\uti #
#                          l_buffer.lst                                       #
#    Object file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Obj\util #
#                          _buffer.r51                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\rssi_test\c\util_buffer.c
      1          /***********************************************************************************
      2            Filename:     util_buffer.c
      3          
      4            Description:  Ringbuffer implementation.
      5          
      6          ***********************************************************************************/
      7          
      8          /***********************************************************************************
      9          * INCLUDES
     10          */
     11          #include "util_buffer.h"
     12          #include "board.h"
     13          #include "int.h"
     14          #include "assert.h"
     15          
     16          /***********************************************************************************
     17          * GLOBAL FUNCTIONS
     18          */
     19          
     20          /***********************************************************************************
     21          * @fn      bufInit
     22          *
     23          * @brief   Initialise a ringbuffer. The buffer must be allocated by the
     24          *          application.
     25          *
     26          * @param   pBuf - pointer to the ringbuffer
     27          *
     28          * @return  none
     29          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     30          void bufInit(ringBuf_t *pBuf)
   \                     bufInit:
     31          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     32              uint16 s;
     33          
     34              // Critical section start
     35              s = halIntLock();
   \   000009                ; Setup parameters for call to function halIntLock
   \   000009   12....       LCALL   ??halIntLock?relay
   \   00000C   8A..         MOV     ?V0 + 2,R2
   \   00000E   8B..         MOV     ?V0 + 3,R3
   \   000010   85....       MOV     ?V0 + 0,?V0 + 2
   \   000013   85....       MOV     ?V0 + 1,?V0 + 3
     36          
     37              pBuf->nBytes= 0;
   \   000016   EE           MOV     A,R6
   \   000017   2440         ADD     A,#0x40
   \   000019   F582         MOV     DPL,A
   \   00001B   EF           MOV     A,R7
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   F583         MOV     DPH,A
   \   000020   7400         MOV     A,#0x0
   \   000022   F0           MOVX    @DPTR,A
     38              pBuf->iHead= 0;
   \   000023   EE           MOV     A,R6
   \   000024   2441         ADD     A,#0x41
   \   000026   F582         MOV     DPL,A
   \   000028   EF           MOV     A,R7
   \   000029   3400         ADDC    A,#0x0
   \   00002B   F583         MOV     DPH,A
   \   00002D   7400         MOV     A,#0x0
   \   00002F   F0           MOVX    @DPTR,A
     39              pBuf->iTail= 0;
   \   000030   EE           MOV     A,R6
   \   000031   2442         ADD     A,#0x42
   \   000033   F582         MOV     DPL,A
   \   000035   EF           MOV     A,R7
   \   000036   3400         ADDC    A,#0x0
   \   000038   F583         MOV     DPH,A
   \   00003A   7400         MOV     A,#0x0
   \   00003C   F0           MOVX    @DPTR,A
     40          
     41              // Critical section end
     42              halIntUnlock(s);
   \   00003D                ; Setup parameters for call to function halIntUnlock
   \   00003D   AA..         MOV     R2,?V0 + 0
   \   00003F   AB..         MOV     R3,?V0 + 1
   \   000041   12....       LCALL   ??halIntUnlock?relay
     43          }
   \   000044   7F04         MOV     R7,#0x4
   \   000046   02....       LJMP    ?BANKED_LEAVE_XDATA
     44          
     45          
     46          /***********************************************************************************
     47          * @fn      bufPut
     48          *
     49          * @brief   Add bytes to the buffer.
     50          *
     51          * @param   pBuf - pointer to the ringbuffer
     52          *          pData - pointer to data to be appended to the buffer
     53          *          nBytes - number of bytes
     54          *
     55          * @return  Number of bytes copied to the buffer
     56          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     57          uint8 bufPut(ringBuf_t *pBuf, const uint8 *pData, uint8 nBytes)
   \                     bufPut:
     58          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 7,R1
     59              uint8 i;
     60              uint16 s;
     61          
     62              // Critical section start
     63              s = halIntLock();
   \   00000F                ; Setup parameters for call to function halIntLock
   \   00000F   12....       LCALL   ??halIntLock?relay
   \   000012   8A..         MOV     ?V0 + 4,R2
   \   000014   8B..         MOV     ?V0 + 5,R3
   \   000016   85....       MOV     ?V0 + 2,?V0 + 4
   \   000019   85....       MOV     ?V0 + 3,?V0 + 5
     64              
     65              if (pBuf->nBytes+nBytes < BUF_SIZE) {
   \   00001C   EE           MOV     A,R6
   \   00001D   2440         ADD     A,#0x40
   \   00001F   F582         MOV     DPL,A
   \   000021   EF           MOV     A,R7
   \   000022   3400         ADDC    A,#0x0
   \   000024   F583         MOV     DPH,A
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   7900         MOV     R1,#0x0
   \   00002A   85....       MOV     ?V0 + 4,?V0 + 7
   \   00002D   75..00       MOV     ?V0 + 5,#0x0
   \   000030   25..         ADD     A,?V0 + 4
   \   000032   F8           MOV     R0,A
   \   000033   E9           MOV     A,R1
   \   000034   35..         ADDC    A,?V0 + 5
   \   000036   F9           MOV     R1,A
   \   000037   C3           CLR     C
   \   000038   E8           MOV     A,R0
   \   000039   9440         SUBB    A,#0x40
   \   00003B   E9           MOV     A,R1
   \   00003C   9400         SUBB    A,#0x0
   \   00003E   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000040   65D0         XRL     A,PSW
   \   000042   33           RLC     A
   \   000043   5076         JNC     ??bufPut_0
     66          
     67                  i= 0;
   \   000045   75..00       MOV     ?V0 + 6,#0x0
     68                  while(i<nBytes) {
   \                     ??bufPut_1:
   \   000048   E5..         MOV     A,?V0 + 6
   \   00004A   C3           CLR     C
   \   00004B   95..         SUBB    A,?V0 + 7
   \   00004D   505C         JNC     ??bufPut_2
     69                      pBuf->pData[pBuf->iTail]= pData[i];
   \   00004F   85....       MOV     ?V0 + 4,?V0 + 6
   \   000052   75..00       MOV     ?V0 + 5,#0x0
   \   000055   E5..         MOV     A,?V0 + 0
   \   000057   25..         ADD     A,?V0 + 4
   \   000059   F582         MOV     DPL,A
   \   00005B   E5..         MOV     A,?V0 + 1
   \   00005D   35..         ADDC    A,?V0 + 5
   \   00005F   F583         MOV     DPH,A
   \   000061   E0           MOVX    A,@DPTR
   \   000062   C0E0         PUSH    A
   \   000064   EE           MOV     A,R6
   \   000065   2442         ADD     A,#0x42
   \   000067   F582         MOV     DPL,A
   \   000069   EF           MOV     A,R7
   \   00006A   3400         ADDC    A,#0x0
   \   00006C   F583         MOV     DPH,A
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F8           MOV     R0,A
   \   000070   7900         MOV     R1,#0x0
   \   000072   EE           MOV     A,R6
   \   000073   28           ADD     A,R0
   \   000074   F582         MOV     DPL,A
   \   000076   EF           MOV     A,R7
   \   000077   39           ADDC    A,R1
   \   000078   F583         MOV     DPH,A
   \   00007A   D0E0         POP     A
   \   00007C   F0           MOVX    @DPTR,A
     70                      pBuf->iTail++;
   \   00007D   EE           MOV     A,R6
   \   00007E   2442         ADD     A,#0x42
   \   000080   F582         MOV     DPL,A
   \   000082   EF           MOV     A,R7
   \   000083   3400         ADDC    A,#0x0
   \   000085   F583         MOV     DPH,A
   \   000087   E0           MOVX    A,@DPTR
   \   000088   2401         ADD     A,#0x1
   \   00008A   F0           MOVX    @DPTR,A
     71                      if (pBuf->iTail==BUF_SIZE)
   \   00008B   EE           MOV     A,R6
   \   00008C   2442         ADD     A,#0x42
   \   00008E   F582         MOV     DPL,A
   \   000090   EF           MOV     A,R7
   \   000091   3400         ADDC    A,#0x0
   \   000093   F583         MOV     DPH,A
   \   000095   E0           MOVX    A,@DPTR
   \   000096   6440         XRL     A,#0x40
   \   000098   700D         JNZ     ??bufPut_3
     72                          pBuf->iTail= 0;
   \   00009A   EE           MOV     A,R6
   \   00009B   2442         ADD     A,#0x42
   \   00009D   F582         MOV     DPL,A
   \   00009F   EF           MOV     A,R7
   \   0000A0   3400         ADDC    A,#0x0
   \   0000A2   F583         MOV     DPH,A
   \   0000A4   7400         MOV     A,#0x0
   \   0000A6   F0           MOVX    @DPTR,A
     73                      i++;
   \                     ??bufPut_3:
   \   0000A7   05..         INC     ?V0 + 6
   \   0000A9   809D         SJMP    ??bufPut_1
     74                  }
     75                  pBuf->nBytes+= i;
   \                     ??bufPut_2:
   \   0000AB   EE           MOV     A,R6
   \   0000AC   2440         ADD     A,#0x40
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   EF           MOV     A,R7
   \   0000B1   3400         ADDC    A,#0x0
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   25..         ADD     A,?V0 + 6
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   8003         SJMP    ??bufPut_4
     76              } else {
     77                  i= 0;
   \                     ??bufPut_0:
   \   0000BB   75..00       MOV     ?V0 + 6,#0x0
     78              }
     79          
     80              // Critical section end
     81              halIntUnlock(s);
   \                     ??bufPut_4:
   \   0000BE                ; Setup parameters for call to function halIntUnlock
   \   0000BE   AA..         MOV     R2,?V0 + 2
   \   0000C0   AB..         MOV     R3,?V0 + 3
   \   0000C2   12....       LCALL   ??halIntUnlock?relay
     82          
     83              return i;
   \   0000C5   A9..         MOV     R1,?V0 + 6
   \   0000C7   7F08         MOV     R7,#0x8
   \   0000C9   02....       LJMP    ?BANKED_LEAVE_XDATA
     84          }
     85          
     86          
     87          /***********************************************************************************
     88          * @fn      bufGet
     89          *
     90          * @brief   Extract bytes from the buffer.
     91          *
     92          * @param   pBuf   - pointer to the ringbuffer
     93          *          pData  - pointer to data to be extracted
     94          *          nBytes - number of bytes
     95          *
     96          * @return  Bytes actually returned
     97          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     98          uint8 bufGet(ringBuf_t *pBuf, uint8 *pData, uint8 nBytes)
   \                     bufGet:
     99          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 5,R1
    100              uint8 i;
    101              uint16 s;
    102          
    103              // Critical section start
    104              s = halIntLock();
   \   00000F                ; Setup parameters for call to function halIntLock
   \   00000F   12....       LCALL   ??halIntLock?relay
   \   000012   8A..         MOV     ?V0 + 6,R2
   \   000014   8B..         MOV     ?V0 + 7,R3
   \   000016   85....       MOV     ?V0 + 2,?V0 + 6
   \   000019   85....       MOV     ?V0 + 3,?V0 + 7
    105          
    106              i= 0;
   \   00001C   75..00       MOV     ?V0 + 4,#0x0
    107              while(i<nBytes && i<pBuf->nBytes) {
   \                     ??bufGet_0:
   \   00001F   E5..         MOV     A,?V0 + 4
   \   000021   C3           CLR     C
   \   000022   95..         SUBB    A,?V0 + 5
   \   000024   506E         JNC     ??bufGet_1
   \   000026   EE           MOV     A,R6
   \   000027   2440         ADD     A,#0x40
   \   000029   F582         MOV     DPL,A
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   F583         MOV     DPH,A
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   E5..         MOV     A,?V0 + 4
   \   000034   C3           CLR     C
   \   000035   98           SUBB    A,R0
   \   000036   505C         JNC     ??bufGet_1
    108                  pData[i]= pBuf->pData[pBuf->iHead];
   \   000038   EE           MOV     A,R6
   \   000039   2441         ADD     A,#0x41
   \   00003B   F582         MOV     DPL,A
   \   00003D   EF           MOV     A,R7
   \   00003E   3400         ADDC    A,#0x0
   \   000040   F583         MOV     DPH,A
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   7900         MOV     R1,#0x0
   \   000046   EE           MOV     A,R6
   \   000047   28           ADD     A,R0
   \   000048   F582         MOV     DPL,A
   \   00004A   EF           MOV     A,R7
   \   00004B   39           ADDC    A,R1
   \   00004C   F583         MOV     DPH,A
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   C0E0         PUSH    A
   \   000051   85....       MOV     ?V0 + 6,?V0 + 4
   \   000054   75..00       MOV     ?V0 + 7,#0x0
   \   000057   E5..         MOV     A,?V0 + 0
   \   000059   25..         ADD     A,?V0 + 6
   \   00005B   F582         MOV     DPL,A
   \   00005D   E5..         MOV     A,?V0 + 1
   \   00005F   35..         ADDC    A,?V0 + 7
   \   000061   F583         MOV     DPH,A
   \   000063   D0E0         POP     A
   \   000065   F0           MOVX    @DPTR,A
    109                  pBuf->iHead++;
   \   000066   EE           MOV     A,R6
   \   000067   2441         ADD     A,#0x41
   \   000069   F582         MOV     DPL,A
   \   00006B   EF           MOV     A,R7
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   F583         MOV     DPH,A
   \   000070   E0           MOVX    A,@DPTR
   \   000071   2401         ADD     A,#0x1
   \   000073   F0           MOVX    @DPTR,A
    110                  if (pBuf->iHead==BUF_SIZE)
   \   000074   EE           MOV     A,R6
   \   000075   2441         ADD     A,#0x41
   \   000077   F582         MOV     DPL,A
   \   000079   EF           MOV     A,R7
   \   00007A   3400         ADDC    A,#0x0
   \   00007C   F583         MOV     DPH,A
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   6440         XRL     A,#0x40
   \   000081   700D         JNZ     ??bufGet_2
    111                      pBuf->iHead= 0;
   \   000083   EE           MOV     A,R6
   \   000084   2441         ADD     A,#0x41
   \   000086   F582         MOV     DPL,A
   \   000088   EF           MOV     A,R7
   \   000089   3400         ADDC    A,#0x0
   \   00008B   F583         MOV     DPH,A
   \   00008D   7400         MOV     A,#0x0
   \   00008F   F0           MOVX    @DPTR,A
    112                  i++;
   \                     ??bufGet_2:
   \   000090   05..         INC     ?V0 + 4
   \   000092   808B         SJMP    ??bufGet_0
    113              }
    114              pBuf->nBytes-= i;
   \                     ??bufGet_1:
   \   000094   EE           MOV     A,R6
   \   000095   2440         ADD     A,#0x40
   \   000097   F582         MOV     DPL,A
   \   000099   EF           MOV     A,R7
   \   00009A   3400         ADDC    A,#0x0
   \   00009C   F583         MOV     DPH,A
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   C3           CLR     C
   \   0000A0   95..         SUBB    A,?V0 + 4
   \   0000A2   F0           MOVX    @DPTR,A
    115          
    116              // Critical section end
    117              halIntUnlock(s);
   \   0000A3                ; Setup parameters for call to function halIntUnlock
   \   0000A3   AA..         MOV     R2,?V0 + 2
   \   0000A5   AB..         MOV     R3,?V0 + 3
   \   0000A7   12....       LCALL   ??halIntUnlock?relay
    118              return i;
   \   0000AA   A9..         MOV     R1,?V0 + 4
   \   0000AC   7F08         MOV     R7,#0x8
   \   0000AE   02....       LJMP    ?BANKED_LEAVE_XDATA
    119          }
    120          
    121          
    122          /***********************************************************************************
    123          * @fn      bufPeek
    124          *
    125          * @brief   Read bytes from the buffer but leave them in the queue.
    126          *
    127          * @param   pBuf   - pointer to the ringbuffer
    128          *          pData  - pointer to data to be extracted
    129          *          nBytes - number of bytes
    130          *
    131          * @return  Bytes actually returned
    132          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    133          uint8 bufPeek(ringBuf_t *pBuf, uint8 *pData, uint8 nBytes)
   \                     bufPeek:
    134          {
   \   000000   74EF         MOV     A,#-0x11
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 17
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 8,R1
    135              uint8 i,j;
    136              uint16 s;
    137          
    138              // Critical section start
    139              s = halIntLock();
   \   00000F                ; Setup parameters for call to function halIntLock
   \   00000F   12....       LCALL   ??halIntLock?relay
   \   000012   8A..         MOV     ?V0 + 4,R2
   \   000014   8B..         MOV     ?V0 + 5,R3
   \   000016   85....       MOV     ?V0 + 2,?V0 + 4
   \   000019   85....       MOV     ?V0 + 3,?V0 + 5
    140          
    141              i= 0;
   \   00001C   75..00       MOV     ?V0 + 6,#0x0
    142              j= pBuf->iHead;
   \   00001F   EE           MOV     A,R6
   \   000020   2441         ADD     A,#0x41
   \   000022   F582         MOV     DPL,A
   \   000024   EF           MOV     A,R7
   \   000025   3400         ADDC    A,#0x0
   \   000027   F583         MOV     DPH,A
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F5..         MOV     ?V0 + 7,A
    143              while(i<nBytes && i<pBuf->nBytes) {
   \                     ??bufPeek_0:
   \   00002C   E5..         MOV     A,?V0 + 6
   \   00002E   C3           CLR     C
   \   00002F   95..         SUBB    A,?V0 + 8
   \   000031   5049         JNC     ??bufPeek_1
   \   000033   EE           MOV     A,R6
   \   000034   2440         ADD     A,#0x40
   \   000036   F582         MOV     DPL,A
   \   000038   EF           MOV     A,R7
   \   000039   3400         ADDC    A,#0x0
   \   00003B   F583         MOV     DPH,A
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F8           MOV     R0,A
   \   00003F   E5..         MOV     A,?V0 + 6
   \   000041   C3           CLR     C
   \   000042   98           SUBB    A,R0
   \   000043   5037         JNC     ??bufPeek_1
    144                  pData[i]= pBuf->pData[j];
   \   000045   85....       MOV     ?V0 + 4,?V0 + 7
   \   000048   75..00       MOV     ?V0 + 5,#0x0
   \   00004B   EE           MOV     A,R6
   \   00004C   25..         ADD     A,?V0 + 4
   \   00004E   F582         MOV     DPL,A
   \   000050   EF           MOV     A,R7
   \   000051   35..         ADDC    A,?V0 + 5
   \   000053   F583         MOV     DPH,A
   \   000055   E0           MOVX    A,@DPTR
   \   000056   C0E0         PUSH    A
   \   000058   85....       MOV     ?V0 + 4,?V0 + 6
   \   00005B   75..00       MOV     ?V0 + 5,#0x0
   \   00005E   E5..         MOV     A,?V0 + 0
   \   000060   25..         ADD     A,?V0 + 4
   \   000062   F582         MOV     DPL,A
   \   000064   E5..         MOV     A,?V0 + 1
   \   000066   35..         ADDC    A,?V0 + 5
   \   000068   F583         MOV     DPH,A
   \   00006A   D0E0         POP     A
   \   00006C   F0           MOVX    @DPTR,A
    145                  j++;
   \   00006D   05..         INC     ?V0 + 7
    146                  if (j==BUF_SIZE)
   \   00006F   7440         MOV     A,#0x40
   \   000071   65..         XRL     A,?V0 + 7
   \   000073   7003         JNZ     ??bufPeek_2
    147                      j= 0;
   \   000075   75..00       MOV     ?V0 + 7,#0x0
    148                  i++;
   \                     ??bufPeek_2:
   \   000078   05..         INC     ?V0 + 6
   \   00007A   80B0         SJMP    ??bufPeek_0
    149              }
    150          
    151              // Critical section end
    152              halIntUnlock(s);
   \                     ??bufPeek_1:
   \   00007C                ; Setup parameters for call to function halIntUnlock
   \   00007C   AA..         MOV     R2,?V0 + 2
   \   00007E   AB..         MOV     R3,?V0 + 3
   \   000080   12....       LCALL   ??halIntUnlock?relay
    153              return i;
   \   000083   A9..         MOV     R1,?V0 + 6
   \   000085   7F09         MOV     R7,#0x9
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
    154          }
    155          
    156          
    157          /***********************************************************************************
    158          * @fn      bufNumBytes
    159          *
    160          * @brief   Return the byte count for the ring buffer.
    161          *
    162          * @param   pBuf- pointer to the buffer
    163          *
    164          * @return  Number of bytes present.
    165          */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          uint8 bufNumBytes(ringBuf_t *pBuf)
   \                     bufNumBytes:
    167          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    168              return pBuf->nBytes;
   \   000004   EA           MOV     A,R2
   \   000005   2440         ADD     A,#0x40
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   F583         MOV     DPH,A
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F9           MOV     R1,A
   \   000010   D083         POP     DPH
   \   000012   D082         POP     DPL
   \   000014   02....       LJMP    ?BRET
    169          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??bufInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bufInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??bufPut?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bufPut

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??bufGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bufGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??bufPeek?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bufPeek

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??bufNumBytes?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bufNumBytes
    170          
    171          /***********************************************************************************
    172            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
    173          
    174            IMPORTANT: Your use of this Software is limited to those specific rights
    175            granted under the terms of a software license agreement between the user
    176            who downloaded the software, his/her employer (which must be your employer)
    177            and Texas Instruments Incorporated (the "License").  You may not use this
    178            Software unless you agree to abide by the terms of the License. The License
    179            limits your use, and you acknowledge, that the Software may not be modified,
    180            copied or distributed unless embedded on a Texas Instruments microcontroller
    181            or used solely and exclusively in conjunction with a Texas Instruments radio
    182            frequency transceiver, which is integrated into your product.  Other than for
    183            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
    184            works of, modify, distribute, perform, display or sell this Software and/or
    185            its documentation for any purpose.
    186          
    187            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
    188            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
    189            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
    190            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
    191            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
    192            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
    193            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
    194            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
    195            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
    196            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
    197            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
    198          
    199            Should you have any questions regarding your right to use this Software,
    200            contact Texas Instruments Incorporated at www.TI.com.
    201          ***********************************************************************************/
    202          

   Maximum stack usage in bytes:

     Function          ISTACK PSTACK XSTACK
     --------          ------ ------ ------
     bufGet                1      0     16
       -> halIntLock       0      0     32
       -> halIntUnlock     0      0     32
     bufInit               0      0     12
       -> halIntLock       0      0     24
       -> halIntUnlock     0      0     24
     bufNumBytes           2      0      0
     bufPeek               1      0     17
       -> halIntLock       0      0     34
       -> halIntUnlock     0      0     34
     bufPut                1      0     16
       -> halIntLock       0      0     32
       -> halIntUnlock     0      0     32


   Segment part sizes:

     Function/Label      Bytes
     --------------      -----
     bufInit               73
     bufPut               204
     bufGet               177
     bufPeek              138
     bufNumBytes           23
     ??bufInit?relay        6
     ??bufPut?relay         6
     ??bufGet?relay         6
     ??bufPeek?relay        6
     ??bufNumBytes?relay    6

 
 615 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
 
 645 bytes of CODE memory

Errors: none
Warnings: none
