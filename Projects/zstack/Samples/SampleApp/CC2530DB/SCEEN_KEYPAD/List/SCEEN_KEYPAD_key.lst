###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         11/Feb/2015  16:51:46 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\Source\SCEEN_KEYPAD\SCEEN_KEYP #
#                          AD_key.c                                           #
#    Command line       =  -f "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wEndev.cfg" (-DCPU32MHZ                   #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=1         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=60            #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=30           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=4 -DASSERT_RESET         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=8000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=1000)  #
#                          -DREJOIN_POLL_RATE=440 "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\Source #
#                          \SCEEN_KEYPAD\SCEEN_KEYPAD_key.c" -D NV_INIT -D    #
#                          NV_RESTORE -D HOLD_AUTO_START -D MT_TASK -D        #
#                          xMT_APP_FUNC -D MT_SYS_FUNC -D MT_ZDO_FUNC -D      #
#                          xMT_ZDO_MGMT -D ISR_KEYINTERRUPT -D POWER_SAVING   #
#                          -D xLONG_POLL_TIMES -D xHAVE_TEST_FUN -D           #
#                          RESUME_TIME_TEST -D SCEEN_KEYPAD -D xM_V332 -lC    #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\List\"  #
#                          -lA "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Lis #
#                          t\" --diag_suppress Pe001,Pa010 -o                 #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Obj\"   #
#                          -e --no_cse --no_unroll --no_inline                #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\Source\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\Source\rssi_t #
#                          est\h\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2530DB\..\Source #
#                          \SCEEN_KEYPAD\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14 #
#                          -12-8\Projects\zstack\Samples\SampleApp\CC2530DB\. #
#                          .\..\..\ZMain\TI2530DB\" -I                        #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\" -I "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\hal\target\CC2530EB\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\include\" -I                         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\high_level\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\single_chip\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mt\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8 #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\osal\include\" -I              #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\saddr\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\sdata\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\af\" -I "D:\RE_1_2_0_FORMAL_APP(251)-1 #
#                          4-12-8\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\..\..\..\..\Components\stack\nwk\" -I           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\" -I "D:\RE_1_2_0_FORMAL_APP(251) #
#                          -14-12-8\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\..\..\..\..\..\Components\stack\sec\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sys\" -I "D:\RE_1_2_0_FORMAL_APP(251)- #
#                          14-12-8\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\stack\zdo\" -I          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\zmac\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12 #
#                          -8\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\zmac\f8w\" -On               #
#                          --require_prototypes                               #
#    List file          =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\List\SCE #
#                          EN_KEYPAD_key.lst                                  #
#    Object file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\SCEEN_KEYPAD\Obj\SCEE #
#                          N_KEYPAD_key.r51                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\SCEEN_KEYPAD\SCEEN_KEYPAD_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8a
   \   unsigned char volatile __sfr P1IFG
   \                     P1IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          #include "device.h"
     92          #include "hal_led.h"
     93          #include "NLMEDE.h"
     94          #include "ZDApp.h"
     95          #include "nwk_util.h"
     96          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     97          
     98          /**************************************************************************************************
     99           *                                              MACROS
    100           **************************************************************************************************/
    101          
    102          /**************************************************************************************************
    103           *                                            CONSTANTS
    104           **************************************************************************************************/
    105          #define HAL_KEY_RISING_EDGE   0
    106          #define HAL_KEY_FALLING_EDGE  1
    107          
    108          #define HAL_KEY_DEBOUNCE_VALUE  25
    109          #define HAL_KEY_CLICKED_VALUE  600  //600ms 内没按键中断则按键检测结束，发送检测到的按键次数到应用层
    110          #define HAL_KEY_DOBULETICK_VALUE   1000
    111          /* CPU port interrupt */
    112          #define HAL_KEY_CPU_PORT_0_IF P0IF
    113          #define HAL_KEY_CPU_PORT_1_IF P1IF
    114          #define HAL_KEY_CPU_PORT_2_IF P2IF
    115          
    116          //p1.2
    117          #define HAL_KEY_SW_1_PORT   P1
    118          #define HAL_KEY_SW_1_BIT    BV(2)
    119          #define HAL_KEY_SW_1_SEL    P1SEL
    120          #define HAL_KEY_SW_1_DIR    P1DIR
    121          #define HAL_KEY_SW_1_EDGEBIT  BV(1)
    122          #define HAL_KEY_SW_1_EDGE     HAL_KEY_FALLING_EDGE
    123          #define HAL_KEY_SW_1_IEN      IEN2  /* CPU interrupt mask register */
    124          #define HAL_KEY_SW_1_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    125          #define HAL_KEY_SW_1_ICTL     P1IEN /* Port Interrupt Control register */
    126          #define HAL_KEY_SW_1_ICTLBIT  BV(2) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    127          #define HAL_KEY_SW_1_PXIFG    P1IFG /* Interrupt flag at source */
    128          
    129          //p1.3
    130          #define HAL_KEY_SW_2_PORT   P1
    131          #define HAL_KEY_SW_2_BIT    BV(3)
    132          #define HAL_KEY_SW_2_SEL    P1SEL
    133          #define HAL_KEY_SW_2_DIR    P1DIR
    134          #define HAL_KEY_SW_2_EDGEBIT  BV(1)
    135          #define HAL_KEY_SW_2_EDGE     HAL_KEY_FALLING_EDGE
    136          #define HAL_KEY_SW_2_IEN      IEN2  /* CPU interrupt mask register */
    137          #define HAL_KEY_SW_2_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    138          #define HAL_KEY_SW_2_ICTL     P1IEN /* Port Interrupt Control register */
    139          #define HAL_KEY_SW_2_ICTLBIT  BV(3) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    140          #define HAL_KEY_SW_2_PXIFG    P1IFG /* Interrupt flag at source */
    141          
    142          //p1.5
    143          #define HAL_KEY_SW_3_PORT   P1
    144          #define HAL_KEY_SW_3_BIT    BV(5)
    145          #define HAL_KEY_SW_3_SEL    P1SEL
    146          #define HAL_KEY_SW_3_DIR    P1DIR
    147          #define HAL_KEY_SW_3_EDGEBIT  BV(2)//p1端口的触发模式设置 在PICTL的低第三位（位2）P1.5为高4位地址
    148          #define HAL_KEY_SW_3_EDGE     HAL_KEY_FALLING_EDGE  // 上升沿触发
    149          #define HAL_KEY_SW_3_IEN      IEN2  /* CPU interrupt mask register */
    150          #define HAL_KEY_SW_3_IENBIT   BV(4) /* Mask bit for all of Port_1 */
    151          #define HAL_KEY_SW_3_ICTL     P1IEN /* Port Interrupt Control register */
    152          #define HAL_KEY_SW_3_ICTLBIT  BV(5) /* P1IEN - P1.5 enable/disable bit */ 
    153          #define HAL_KEY_SW_3_PXIFG    P1IFG /* Interrupt flag at source */
    154          
    155          //p1.6
    156          #define HAL_KEY_SW_4_PORT   P1
    157          #define HAL_KEY_SW_4_BIT    BV(6)
    158          #define HAL_KEY_SW_4_SEL    P1SEL
    159          #define HAL_KEY_SW_4_DIR    P1DIR
    160          #define HAL_KEY_SW_4_EDGEBIT  BV(2)
    161          #define HAL_KEY_SW_4_EDGE     HAL_KEY_FALLING_EDGE
    162          #define HAL_KEY_SW_4_IEN      IEN2  /* CPU interrupt mask register */
    163          #define HAL_KEY_SW_4_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    164          #define HAL_KEY_SW_4_ICTL     P1IEN /* Port Interrupt Control register */
    165          #define HAL_KEY_SW_4_ICTLBIT  BV(6) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    166          #define HAL_KEY_SW_4_PXIFG    P1IFG /* Interrupt flag at source */
    167          
    168          //p1.7
    169          #define HAL_KEY_SW_5_PORT   P1
    170          #define HAL_KEY_SW_5_BIT    BV(7)
    171          #define HAL_KEY_SW_5_SEL    P1SEL
    172          #define HAL_KEY_SW_5_DIR    P1DIR
    173          #define HAL_KEY_SW_5_EDGEBIT  BV(2)
    174          #define HAL_KEY_SW_5_EDGE     HAL_KEY_FALLING_EDGE
    175          #define HAL_KEY_SW_5_IEN      IEN2  /* CPU interrupt mask register */
    176          #define HAL_KEY_SW_5_IENBIT   BV(4) /* Mask bit for all of Port_0 */
    177          #define HAL_KEY_SW_5_ICTL     P1IEN /* Port Interrupt Control register */
    178          #define HAL_KEY_SW_5_ICTLBIT  BV(7) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    179          #define HAL_KEY_SW_5_PXIFG    P1IFG /* Interrupt flag at source */
    180          
    181          //p0.4
    182          #define HAL_KEY_SW_6_PORT   P0
    183          #define HAL_KEY_SW_6_BIT    BV(4)
    184          #define HAL_KEY_SW_6_SEL    P0SEL
    185          #define HAL_KEY_SW_6_DIR    P0DIR
    186          #define HAL_KEY_SW_6_EDGEBIT  BV(0)
    187          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    188          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    189          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    190          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    191          #define HAL_KEY_SW_6_ICTLBIT  BV(4) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    192          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    193          
    194          //p0.5
    195          #define HAL_KEY_SW_7_PORT   P0
    196          #define HAL_KEY_SW_7_BIT    BV(5)
    197          #define HAL_KEY_SW_7_SEL    P0SEL
    198          #define HAL_KEY_SW_7_DIR    P0DIR
    199          #define HAL_KEY_SW_7_EDGEBIT  BV(0)
    200          #define HAL_KEY_SW_7_EDGE     HAL_KEY_FALLING_EDGE
    201          #define HAL_KEY_SW_7_IEN      IEN1  /* CPU interrupt mask register */
    202          #define HAL_KEY_SW_7_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    203          #define HAL_KEY_SW_7_ICTL     P0IEN /* Port Interrupt Control register */
    204          #define HAL_KEY_SW_7_ICTLBIT  BV(5) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    205          #define HAL_KEY_SW_7_PXIFG    P0IFG /* Interrupt flag at source */
    206          
    207          
    208          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    209          
    210          
    211          /**************************************************************************************************
    212           *                                            TYPEDEFS
    213           **************************************************************************************************/
    214          
    215          
    216          /**************************************************************************************************
    217           *                                        GLOBAL VARIABLES
    218           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    219          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    220           halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    221          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    222          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    223          uint8 key_press_zdo_flag=0;
   \                     key_press_zdo_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    224          /**************************************************************************************************
    225           *                                        FUNCTIONS - Local
    226           **************************************************************************************************/
    227          void halProcessKeyInterrupt(void);
    228          uint8 halGetJoyKeyInput(void);

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    229          uint8 kpush0=0;
   \                     kpush0:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    230          uint8 kpush1=0;
   \                     kpush1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          uint8 key_ISR_FLAG=0;
   \                     key_ISR_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    232          uint8 key_p1_2_ISR_FLAG=0;//test p1.2口的单击 双击
   \                     key_p1_2_ISR_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          uint8 key_double_flag = 0;//按键双击状态
   \                     key_double_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          uint8 KEY_NET_ISR_FLAG=0;//test p1.2口的单击 双击
   \                     KEY_NET_ISR_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    236          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    237          uint8 key_holdtime_waiting_flag = 0;//等待长按时间（10s）标志 ，0无等待 1正在等待
   \                     key_holdtime_waiting_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    238          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    239          uint8 key_hold_flag = 0;  //按键长按标志
   \                     key_hold_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    240          
    241          
    242          
    243          extern uint8 screen_current_flag;
    244          
    245          extern uint8 screen_flag;
    246          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    247          uint8 zdo_start_flag =0;
   \                     zdo_start_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    248          
    249          extern void PowerMode(uint8 sel);
    250          
    251          uint8 binding_have_entry(void);
    252          
    253          
    254          extern void SampleAPP_send_delay_message(void);
    255          extern void ZDApp_SendMsg( uint8 taskID, uint8 cmd, uint8 len, uint8 *buf );
    256          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    257          uint8 P1_2_FLAG=0;
   \                     P1_2_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    258          /**************************************************************************************************
    259           *                                        FUNCTIONS - API
    260           **************************************************************************************************/
    261          
    262          
    263          /**************************************************************************************************
    264           * @fn      HalKeyInit
    265           *
    266           * @brief   Initilize Key Service
    267           *
    268           * @param   none
    269           *
    270           * @return  None
    271           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    272          void HalKeyInit( void )
   \                     HalKeyInit:
    273          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    274            /* Initialize previous key to 0 */
    275            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    276          
    277              HAL_KEY_SW_1_SEL &= ~(HAL_KEY_SW_1_BIT);    /* Set pin function to GPIO */
   \   00000A   53F4FB       ANL     0xf4,#0xfb
    278            HAL_KEY_SW_1_DIR &= ~(HAL_KEY_SW_1_BIT);    /* Set pin direction to Input */
   \   00000D   53FEFB       ANL     0xfe,#0xfb
    279          
    280          
    281              HAL_KEY_SW_3_SEL &= ~(HAL_KEY_SW_3_BIT);    /* Set pin function to GPIO */
   \   000010   53F4DF       ANL     0xf4,#0xdf
    282            HAL_KEY_SW_3_DIR &= ~(HAL_KEY_SW_3_BIT);    /* Set pin direction to Input */
   \   000013   53FEDF       ANL     0xfe,#0xdf
    283          
    284              HAL_KEY_SW_4_SEL &= ~(HAL_KEY_SW_4_BIT);    /* Set pin function to GPIO */
   \   000016   53F4BF       ANL     0xf4,#0xbf
    285            HAL_KEY_SW_4_DIR &= ~(HAL_KEY_SW_4_BIT);    /* Set pin direction to Input */
   \   000019   53FEBF       ANL     0xfe,#0xbf
    286          
    287            
    288            HAL_KEY_SW_5_SEL &= ~(HAL_KEY_SW_5_BIT);    /* Set pin function to GPIO */
   \   00001C   53F47F       ANL     0xf4,#0x7f
    289            HAL_KEY_SW_5_DIR &= ~(HAL_KEY_SW_5_BIT);    /* Set pin direction to Input */
   \   00001F   53FE7F       ANL     0xfe,#0x7f
    290            
    291            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
   \   000022   53F3EF       ANL     0xf3,#0xef
    292            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
   \   000025   53FDEF       ANL     0xfd,#0xef
    293          
    294            
    295            
    296          
    297            /* Initialize callback function */
    298            pHalKeyProcessFunction  = NULL;
   \   000028   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00002B   7400         MOV     A,#0x0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   7400         MOV     A,#0x0
   \   000031   F0           MOVX    @DPTR,A
    299          
    300            /* Start with key is not configured */
    301            HalKeyConfigured = FALSE;
   \   000032   90....       MOV     DPTR,#HalKeyConfigured
   \   000035   7400         MOV     A,#0x0
   \   000037   F0           MOVX    @DPTR,A
    302          }
   \   000038   D083         POP     DPH
   \   00003A   D082         POP     DPL
   \   00003C   02....       LJMP    ?BRET
   \   00003F                REQUIRE P1SEL
   \   00003F                REQUIRE P1DIR
   \   00003F                REQUIRE P0SEL
   \   00003F                REQUIRE P0DIR
    303          
    304          
    305          /**************************************************************************************************
    306           * @fn      HalKeyConfig
    307           *
    308           * @brief   Configure the Key serivce
    309           *
    310           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    311           *          cback - pointer to the CallBack function
    312           *
    313           * @return  None
    314           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    315          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    316          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    317            /* Enable/Disable Interrupt or */
    318            Hal_KeyIntEnable = interruptEnable;
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000010   F0           MOVX    @DPTR,A
    319          
    320            /* Register the callback fucntion */
    321            pHalKeyProcessFunction = cback;
   \   000011   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000014   EE           MOV     A,R6
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   EF           MOV     A,R7
   \   000018   F0           MOVX    @DPTR,A
    322          
    323            /* Determine if interrupt is enable or not */
    324            if (Hal_KeyIntEnable)
   \   000019   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6061         JZ      ??HalKeyConfig_0
    325            {
    326                /* Rising/Falling edge configuratinn */
    327          
    328              
    329              PICTL &= ~(HAL_KEY_SW_1_EDGEBIT);    /* Clear the edge bit */
   \   00001F   538CFD       ANL     0x8c,#0xfd
    330            #if (HAL_KEY_SW_1_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    331              PICTL |= HAL_KEY_SW_1_EDGEBIT;
   \   000022   438C02       ORL     0x8c,#0x2
    332            #endif
    333              HAL_KEY_SW_1_ICTL |= HAL_KEY_SW_1_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000025   438D04       ORL     0x8d,#0x4
    334              HAL_KEY_SW_1_IEN |= HAL_KEY_SW_1_IENBIT;//使能整个CPU的P0口中断
   \   000028   439A10       ORL     0x9a,#0x10
    335              HAL_KEY_SW_1_PXIFG = ~(HAL_KEY_SW_1_BIT);//清中断标记位
   \   00002B   758AFB       MOV     0x8a,#-0x5
    336              
    337           
    338              
    339             PICTL &= ~(HAL_KEY_SW_3_EDGEBIT);    /* Clear the edge bit */
   \   00002E   538CFB       ANL     0x8c,#0xfb
    340            #if (HAL_KEY_SW_3_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    341              PICTL |= HAL_KEY_SW_3_EDGEBIT;
   \   000031   438C04       ORL     0x8c,#0x4
    342            #endif
    343              HAL_KEY_SW_3_ICTL |= HAL_KEY_SW_3_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000034   438D20       ORL     0x8d,#0x20
    344              HAL_KEY_SW_3_IEN |= HAL_KEY_SW_3_IENBIT;//使能整个CPU的P0口中断
   \   000037   439A10       ORL     0x9a,#0x10
    345              HAL_KEY_SW_3_PXIFG = ~(HAL_KEY_SW_3_BIT);//清中断标记位
   \   00003A   758ADF       MOV     0x8a,#-0x21
    346              
    347              PICTL &= ~(HAL_KEY_SW_4_EDGEBIT);    /* Clear the edge bit */
   \   00003D   538CFB       ANL     0x8c,#0xfb
    348            #if (HAL_KEY_SW_4_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    349              PICTL |= HAL_KEY_SW_4_EDGEBIT;
   \   000040   438C04       ORL     0x8c,#0x4
    350            #endif
    351              HAL_KEY_SW_4_ICTL |= HAL_KEY_SW_4_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000043   438D40       ORL     0x8d,#0x40
    352              HAL_KEY_SW_4_IEN |= HAL_KEY_SW_4_IENBIT;//使能整个CPU的P0口中断
   \   000046   439A10       ORL     0x9a,#0x10
    353              HAL_KEY_SW_4_PXIFG = ~(HAL_KEY_SW_4_BIT);//清中断标记位
   \   000049   758ABF       MOV     0x8a,#-0x41
    354              
    355              
    356              PICTL &= ~(HAL_KEY_SW_5_EDGEBIT);    /* Clear the edge bit */
   \   00004C   538CFB       ANL     0x8c,#0xfb
    357            #if (HAL_KEY_SW_5_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    358              PICTL |= HAL_KEY_SW_5_EDGEBIT;
   \   00004F   438C04       ORL     0x8c,#0x4
    359            #endif
    360              HAL_KEY_SW_5_ICTL |= HAL_KEY_SW_5_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000052   438D80       ORL     0x8d,#0x80
    361              HAL_KEY_SW_5_IEN |= HAL_KEY_SW_5_IENBIT;//使能整个CPU的P0口中断
   \   000055   439A10       ORL     0x9a,#0x10
    362              HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT);//清中断标记位
                                          ^
Warning[Pe069]: integer conversion resulted in truncation
   \   000058   758A7F       MOV     0x8a,#0x7f
    363              
    364              
    365              
    366              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
   \   00005B   538CFE       ANL     0x8c,#0xfe
    367            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    368              PICTL |= HAL_KEY_SW_6_EDGEBIT;
   \   00005E   438C01       ORL     0x8c,#0x1
    369            #endif
    370          
    371              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000061   43AB10       ORL     0xab,#0x10
    372              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;//使能整个CPU的P0口中断
   \   000064   D2BD         SETB    0xb8.5
    373              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);//清中断标记位
   \   000066   7589EF       MOV     0x89,#-0x11
    374            
    375              
    376              
    377             
    378             
    379           
    380              /* Do this only after the hal_key is configured - to work with sleep stuff */
    381              if (HalKeyConfigured == TRUE)
   \   000069   90....       MOV     DPTR,#HalKeyConfigured
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   6401         XRL     A,#0x1
   \   00006F   7021         JNZ     ??HalKeyConfig_1
    382              {
    383                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   000071                ; Setup parameters for call to function osal_stop_timerEx
   \   000071   7A01         MOV     R2,#0x1
   \   000073   7B00         MOV     R3,#0x0
   \   000075   90....       MOV     DPTR,#Hal_TaskID
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F9           MOV     R1,A
   \   00007A   12....       LCALL   ??osal_stop_timerEx?relay
   \   00007D   E9           MOV     A,R1
   \   00007E   8012         SJMP    ??HalKeyConfig_1
    384              }
    385            }
    386            else    /* Interrupts NOT enabled */
    387            {
    388              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt */
   \                     ??HalKeyConfig_0:
   \   000080   53ABEF       ANL     0xab,#0xef
    389              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
   \   000083   C2BD         CLR     0xb8.5
    390          
    391              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
   \   000085                ; Setup parameters for call to function osal_set_event
   \   000085   7A01         MOV     R2,#0x1
   \   000087   7B00         MOV     R3,#0x0
   \   000089   90....       MOV     DPTR,#Hal_TaskID
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F9           MOV     R1,A
   \   00008E   12....       LCALL   ??osal_set_event?relay
   \   000091   E9           MOV     A,R1
    392            }
    393          
    394            /* Key now is configured */
    395            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000092   90....       MOV     DPTR,#HalKeyConfigured
   \   000095   7401         MOV     A,#0x1
   \   000097   F0           MOVX    @DPTR,A
    396          }
   \   000098   7F01         MOV     R7,#0x1
   \   00009A   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00009D                REQUIRE PICTL
   \   00009D                REQUIRE P1IEN
   \   00009D                REQUIRE IEN2
   \   00009D                REQUIRE P1IFG
   \   00009D                REQUIRE P0IEN
   \   00009D                REQUIRE _A_IEN1
   \   00009D                REQUIRE P0IFG
    397          
    398          
    399          /**************************************************************************************************
    400           * @fn      HalKeyRead
    401           *
    402           * @brief   Read the current value of a key
    403           *
    404           * @param   None
    405           *
    406           * @return  keys - current keys status
    407           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    409          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    410            uint8 keys = 0;
   \   000000   7900         MOV     R1,#0x0
    411          
    412            if (HAL_PUSH_BUTTON1())
   \   000002   A292         MOV     C,0x90.2
   \   000004   5005         JNC     ??HalKeyRead_0
    413            {
    414              keys |= HAL_KEY_SW_6;
   \   000006   D3           SETB    C
   \   000007   E9           MOV     A,R1
   \   000008   92E5         MOV     0xE0 /* A   */.5,C
   \   00000A   F9           MOV     R1,A
    415            }
    416          
    417          
    418            return keys;
   \                     ??HalKeyRead_0:
   \   00000B   02....       LJMP    ?BRET
   \   00000E                REQUIRE _A_P1
    419          }
    420          
    421          
    422          /**************************************************************************************************
    423           * @fn      HalKeyPoll
    424           *
    425           * @brief   Called by hal_driver to poll the keys
    426           *
    427           * @param   None
    428           *
    429           * @return  None
    430          
    431          key_press_zdo_flag // 是否是按键导致的事件标记，如果是按键按下的，则置位，在处理完按键时间
    432          或者由于入网事件后清零
    433          sceen_flag  按下这个按键对应的场景的ID号。对应1 2 3 4 5 6
    434          Put_in_powermode_flag 是否过了配置期的1分钟时间
    435          zdo_start_flag  ZDO的搜网的状态，如果到了20次，不搜索网络了则置位
    436          
    437           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    438          void HalKeyPoll (void)
   \                     HalKeyPoll:
    439          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    440           uint8 keys = 0;
   \   000005   7E00         MOV     R6,#0x0
    441          
    442          
    443            
    444          
    445            /* If interrupts are not enabled, previous key status and current key status
    446             * are compared to find out if a key has changed status.
    447             */
    448            if (!Hal_KeyIntEnable)
   \   000007   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   7012         JNZ     ??HalKeyPoll_0
    449            {
    450              if (keys == halKeySavedKeys)
   \   00000D   90....       MOV     DPTR,#halKeySavedKeys
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6E           XRL     A,R6
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??HalKeyPoll_1 & 0xFFFF
    451              {
    452                 /* Exit - since no keys have changed */
    453                return;
    454              }
    455              /* Store the current keys for comparation next time */
    456              halKeySavedKeys = keys;
   \   000017   EE           MOV     A,R6
   \   000018   90....       MOV     DPTR,#halKeySavedKeys
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    457            }
    458            else
    459            {
    460              /* Key interrupt handled here */
    461                 
    462             
    463             // 开始有绑定功能
    464               if (((key_ISR_FLAG & HAL_KEY_SW_9)!=0) && (!HAL_PUSH_BUTTON3()))//初步理解，设置p0.4为下降沿触发，触发唤醒系统后，25ms到这，判断是否为0，是0则读取见键值
   \                     ??HalKeyPoll_0:
   \   00001F   90....       MOV     DPTR,#key_ISR_FLAG
   \   000022   E0           MOVX    A,@DPTR
   \   000023   A2E6         MOV     C,0xE0 /* A   */.6
   \   000025   5030         JNC     ??HalKeyPoll_3
   \   000027   A295         MOV     C,0x90.5
   \   000029   402C         JC      ??HalKeyPoll_3
    465             {
    466               //HalLedBlink ( HAL_LED_2, 1, 50, 200 );
    467               
    468               key_press_zdo_flag = 1;//有按键按下
   \   00002B   90....       MOV     DPTR,#key_press_zdo_flag
   \   00002E   7401         MOV     A,#0x1
   \   000030   F0           MOVX    @DPTR,A
    469               screen_flag = 1;// 对应场景为2
   \   000031   90....       MOV     DPTR,#screen_flag
   \   000034   7401         MOV     A,#0x1
   \   000036   F0           MOVX    @DPTR,A
    470               if(devState == DEV_END_DEVICE)
   \   000037   90....       MOV     DPTR,#devState
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   6406         XRL     A,#0x6
   \   00003D   6003         JZ      $+5
   \   00003F   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    471               {
    472                  if(P1_2==1) //如果没有按下加网键
   \   000042   A292         MOV     C,0x90.2
   \   000044   5003         JNC     ??HalKeyPoll_4
    473                  SampleAPP_send_delay_message();
   \   000046                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   000046   12....       LCALL   ??SampleAPP_send_delay_message?relay
    474                  screen_flag = 0;
   \                     ??HalKeyPoll_4:
   \   000049   90....       MOV     DPTR,#screen_flag
   \   00004C   7400         MOV     A,#0x0
   \   00004E   F0           MOVX    @DPTR,A
    475          /*        if(Put_in_powermode_flag ==1) // 如果已经过了配置期，则可以进入按键休眠模式
    476                {
    477                  NLME_SetPollRate( 1000 );
    478                  osal_stop_timerEx (SampleApp_TaskID , POWERMODE_EVT);
    479                  osal_start_timerEx( SampleApp_TaskID,POWERMODE_EVT,6000 );
    480                }*/
    481                keys |= HAL_KEY_SW_9;
   \   00004F   D3           SETB    C
   \   000050   EE           MOV     A,R6
   \   000051   92E6         MOV     0xE0 /* A   */.6,C
   \   000053   FE           MOV     R6,A
   \   000054   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    482               }
    483             }
    484              else if (((key_ISR_FLAG & HAL_KEY_SW_4)!=0) && (!HAL_PUSH_BUTTON4()))//初步理解，设置p0.4为下降沿触发，触发唤醒系统后，25ms到这，判断是否为0，是0则读取见键值
   \                     ??HalKeyPoll_3:
   \   000057   90....       MOV     DPTR,#key_ISR_FLAG
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   A2E3         MOV     C,0xE0 /* A   */.3
   \   00005D   5030         JNC     ??HalKeyPoll_5
   \   00005F   A296         MOV     C,0x90.6
   \   000061   402C         JC      ??HalKeyPoll_5
    485             {
    486                   //HalLedBlink ( HAL_LED_2, 1, 50, 200 );
    487                key_press_zdo_flag = 1;//有按键按下
   \   000063   90....       MOV     DPTR,#key_press_zdo_flag
   \   000066   7401         MOV     A,#0x1
   \   000068   F0           MOVX    @DPTR,A
    488                screen_flag = 2;// 对应场景为2
   \   000069   90....       MOV     DPTR,#screen_flag
   \   00006C   7402         MOV     A,#0x2
   \   00006E   F0           MOVX    @DPTR,A
    489               if(devState == DEV_END_DEVICE)
   \   00006F   90....       MOV     DPTR,#devState
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6406         XRL     A,#0x6
   \   000075   6003         JZ      $+5
   \   000077   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    490               {
    491                  if(P1_2==1) //如果没有按下加网键
   \   00007A   A292         MOV     C,0x90.2
   \   00007C   5003         JNC     ??HalKeyPoll_6
    492                  SampleAPP_send_delay_message();
   \   00007E                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   00007E   12....       LCALL   ??SampleAPP_send_delay_message?relay
    493                  screen_flag = 0;
   \                     ??HalKeyPoll_6:
   \   000081   90....       MOV     DPTR,#screen_flag
   \   000084   7400         MOV     A,#0x0
   \   000086   F0           MOVX    @DPTR,A
    494                  /*if(Put_in_powermode_flag ==1) // 如果已经过了配置期，则可以进入按键休眠模式
    495                {
    496                  NLME_SetPollRate( 1000 );
    497                  osal_stop_timerEx (SampleApp_TaskID , POWERMODE_EVT);
    498                  osal_start_timerEx( SampleApp_TaskID,POWERMODE_EVT,6000 );
    499                }*/
    500                keys |= HAL_KEY_SW_4;
   \   000087   D3           SETB    C
   \   000088   EE           MOV     A,R6
   \   000089   92E3         MOV     0xE0 /* A   */.3,C
   \   00008B   FE           MOV     R6,A
   \   00008C   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    501               }
    502             }
    503             else  if (((key_ISR_FLAG &HAL_KEY_SW_5)!= 0) && (!HAL_PUSH_BUTTON5()))//初步理解，设置p0.4为下降沿触发，触发唤醒系统后，25ms到这，判断是否为0，是0则读取见键值
   \                     ??HalKeyPoll_5:
   \   00008F   90....       MOV     DPTR,#key_ISR_FLAG
   \   000092   E0           MOVX    A,@DPTR
   \   000093   A2E2         MOV     C,0xE0 /* A   */.2
   \   000095   5030         JNC     ??HalKeyPoll_7
   \   000097   A297         MOV     C,0x90.7
   \   000099   402C         JC      ??HalKeyPoll_7
    504             {
    505                   //HalLedBlink ( HAL_LED_2, 1, 50, 200 );
    506                key_press_zdo_flag = 1;//有按键按下
   \   00009B   90....       MOV     DPTR,#key_press_zdo_flag
   \   00009E   7401         MOV     A,#0x1
   \   0000A0   F0           MOVX    @DPTR,A
    507                screen_flag = 3;// 对应场景为2
   \   0000A1   90....       MOV     DPTR,#screen_flag
   \   0000A4   7403         MOV     A,#0x3
   \   0000A6   F0           MOVX    @DPTR,A
    508              if(devState == DEV_END_DEVICE)
   \   0000A7   90....       MOV     DPTR,#devState
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   6406         XRL     A,#0x6
   \   0000AD   6003         JZ      $+5
   \   0000AF   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    509               {
    510                  if(P1_2==1) //如果没有按下加网键
   \   0000B2   A292         MOV     C,0x90.2
   \   0000B4   5003         JNC     ??HalKeyPoll_8
    511                  SampleAPP_send_delay_message();
   \   0000B6                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   0000B6   12....       LCALL   ??SampleAPP_send_delay_message?relay
    512                  screen_flag = 0;
   \                     ??HalKeyPoll_8:
   \   0000B9   90....       MOV     DPTR,#screen_flag
   \   0000BC   7400         MOV     A,#0x0
   \   0000BE   F0           MOVX    @DPTR,A
    513                 /*if(Put_in_powermode_flag ==1) // 如果已经过了配置期，则可以进入按键休眠模式
    514                {
    515                  NLME_SetPollRate( 1000 );
    516                  osal_stop_timerEx (SampleApp_TaskID , POWERMODE_EVT);
    517                  osal_start_timerEx( SampleApp_TaskID,POWERMODE_EVT,6000 );
    518                }*/
    519                keys |= HAL_KEY_SW_5;
   \   0000BF   D3           SETB    C
   \   0000C0   EE           MOV     A,R6
   \   0000C1   92E2         MOV     0xE0 /* A   */.2,C
   \   0000C3   FE           MOV     R6,A
   \   0000C4   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    520               }
    521             }
    522             else  if (((key_ISR_FLAG & HAL_KEY_SW_6)!= 0) && (!HAL_PUSH_BUTTON6()))//初步理解，设置p0.4为下降沿触发，触发唤醒系统后，25ms到这，判断是否为0，是0则读取见键值
   \                     ??HalKeyPoll_7:
   \   0000C7   90....       MOV     DPTR,#key_ISR_FLAG
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   A2E5         MOV     C,0xE0 /* A   */.5
   \   0000CD   502C         JNC     ??HalKeyPoll_9
   \   0000CF   A284         MOV     C,0x80.4
   \   0000D1   4028         JC      ??HalKeyPoll_9
    523             {
    524                   //HalLedBlink ( HAL_LED_2, 1, 50, 200 );
    525                 key_press_zdo_flag = 1;//有按键按下
   \   0000D3   90....       MOV     DPTR,#key_press_zdo_flag
   \   0000D6   7401         MOV     A,#0x1
   \   0000D8   F0           MOVX    @DPTR,A
    526                 screen_flag = 4;// 对应场景为2
   \   0000D9   90....       MOV     DPTR,#screen_flag
   \   0000DC   7404         MOV     A,#0x4
   \   0000DE   F0           MOVX    @DPTR,A
    527                if(devState == DEV_END_DEVICE)
   \   0000DF   90....       MOV     DPTR,#devState
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   6406         XRL     A,#0x6
   \   0000E5   706A         JNZ     ??HalKeyPoll_2
    528               {
    529                    if(P1_2==1) //如果没有按下加网键
   \   0000E7   A292         MOV     C,0x90.2
   \   0000E9   5003         JNC     ??HalKeyPoll_10
    530                    SampleAPP_send_delay_message();
   \   0000EB                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   0000EB   12....       LCALL   ??SampleAPP_send_delay_message?relay
    531                    screen_flag = 0;
   \                     ??HalKeyPoll_10:
   \   0000EE   90....       MOV     DPTR,#screen_flag
   \   0000F1   7400         MOV     A,#0x0
   \   0000F3   F0           MOVX    @DPTR,A
    532                /* if(Put_in_powermode_flag ==1) // 如果已经过了配置期，则可以进入按键休眠模式
    533                {
    534                  NLME_SetPollRate( 1000 );
    535                  osal_stop_timerEx (SampleApp_TaskID , POWERMODE_EVT);
    536                  osal_start_timerEx( SampleApp_TaskID,POWERMODE_EVT,6000 );
    537                }*/
    538                keys |= HAL_KEY_SW_6;
   \   0000F4   D3           SETB    C
   \   0000F5   EE           MOV     A,R6
   \   0000F6   92E5         MOV     0xE0 /* A   */.5,C
   \   0000F8   FE           MOV     R6,A
   \   0000F9   8056         SJMP    ??HalKeyPoll_2
    539               }
    540             }
    541             
    542             else if (((key_ISR_FLAG & HAL_KEY_SW_1)!= 0) && (!(HAL_PUSH_BUTTON1())))
   \                     ??HalKeyPoll_9:
   \   0000FB   90....       MOV     DPTR,#key_ISR_FLAG
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   A2E0         MOV     C,0xE0 /* A   */.0
   \   000101   504E         JNC     ??HalKeyPoll_2
   \   000103   A292         MOV     C,0x90.2
   \   000105   404A         JC      ??HalKeyPoll_2
    543              {
    544                key_press_zdo_flag = 1;
   \   000107   90....       MOV     DPTR,#key_press_zdo_flag
   \   00010A   7401         MOV     A,#0x1
   \   00010C   F0           MOVX    @DPTR,A
    545               /* if(Put_in_powermode_flag ==1) // 如果已经过了配置期，则可以进入按键休眠模式
    546                {
    547                 NLME_SetPollRate( 1000 );
    548                 osal_stop_timerEx (SampleApp_TaskID , POWERMODE_EVT);
    549                 osal_start_timerEx( SampleApp_TaskID,POWERMODE_EVT,8000 );
    550                }*/
    551               
    552                
    553           //      HalLedBlink ( HAL_LED_2, 1, 50, 500 );
    554               if(key_holdtime_waiting_flag)
   \   00010D   90....       MOV     DPTR,#key_holdtime_waiting_flag
   \   000110   E0           MOVX    A,@DPTR
   \   000111   6019         JZ      ??HalKeyPoll_11
    555          	 {
    556          	   key_holdtime_waiting_flag = 0;//在等待长按时间时再次按下按钮 此时需要清等待长按时间标志以及取消之前设置的等待长按时间满以后进入事件
   \   000113   90....       MOV     DPTR,#key_holdtime_waiting_flag
   \   000116   7400         MOV     A,#0x0
   \   000118   F0           MOVX    @DPTR,A
    557          	   osal_stop_timerEx (Hal_TaskID, HAL_KEY_HOLD_EVENT);//  停止之前进入的事件
   \   000119                ; Setup parameters for call to function osal_stop_timerEx
   \   000119   7A40         MOV     R2,#0x40
   \   00011B   7B00         MOV     R3,#0x0
   \   00011D   90....       MOV     DPTR,#Hal_TaskID
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   ??osal_stop_timerEx?relay
   \   000125   E9           MOV     A,R1
    558          	   KEY_NET_ISR_FLAG = 0;// 等待长按时间被打断后 重新计数按键次数
   \   000126   90....       MOV     DPTR,#KEY_NET_ISR_FLAG
   \   000129   7400         MOV     A,#0x0
   \   00012B   F0           MOVX    @DPTR,A
    559          	 }
    560          	 KEY_NET_ISR_FLAG++;//test 测试单击 双击等程序
   \                     ??HalKeyPoll_11:
   \   00012C   90....       MOV     DPTR,#KEY_NET_ISR_FLAG
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   2401         ADD     A,#0x1
   \   000132   F0           MOVX    @DPTR,A
    561               osal_stop_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT);//  停止之前进入的事件
   \   000133                ; Setup parameters for call to function osal_stop_timerEx
   \   000133   7A20         MOV     R2,#0x20
   \   000135   7B00         MOV     R3,#0x0
   \   000137   90....       MOV     DPTR,#Hal_TaskID
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   F9           MOV     R1,A
   \   00013C   12....       LCALL   ??osal_stop_timerEx?relay
   \   00013F   E9           MOV     A,R1
    562               osal_start_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT, HAL_KEY_CLICKED_VALUE);//600mS后触发检测几击程序
   \   000140                ; Setup parameters for call to function osal_start_timerEx
   \   000140   7C58         MOV     R4,#0x58
   \   000142   7D02         MOV     R5,#0x2
   \   000144   7A20         MOV     R2,#0x20
   \   000146   7B00         MOV     R3,#0x0
   \   000148   90....       MOV     DPTR,#Hal_TaskID
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   F9           MOV     R1,A
   \   00014D   12....       LCALL   ??osal_start_timerEx?relay
   \   000150   E9           MOV     A,R1
    563               
    564           
    565             }
    566            
    567            }
    568          
    569           
    570            /* Invoke Callback if new keys were depressed */
    571            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_2:
   \   000151   EE           MOV     A,R6
   \   000152   6024         JZ      ??HalKeyPoll_1
   \   000154   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000157   E0           MOVX    A,@DPTR
   \   000158   F8           MOV     R0,A
   \   000159   A3           INC     DPTR
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F9           MOV     R1,A
   \   00015C   E8           MOV     A,R0
   \   00015D   49           ORL     A,R1
   \   00015E   6018         JZ      ??HalKeyPoll_1
    572            {
    573              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   000160                ; Setup parameters for indirect call
   \   000160   7A00         MOV     R2,#0x0
   \   000162   EE           MOV     A,R6
   \   000163   F9           MOV     R1,A
   \   000164   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000167   E0           MOVX    A,@DPTR
   \   000168   F8           MOV     R0,A
   \   000169   A3           INC     DPTR
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   F583         MOV     DPH,A
   \   00016D   8882         MOV     DPL,R0
   \   00016F   12....       LCALL   ?CALL_IND
    574              key_ISR_FLAG=0;
   \   000172   90....       MOV     DPTR,#key_ISR_FLAG
   \   000175   7400         MOV     A,#0x0
   \   000177   F0           MOVX    @DPTR,A
    575            }
    576          }
   \                     ??HalKeyPoll_1:
   \   000178   7F01         MOV     R7,#0x1
   \   00017A   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00017D                REQUIRE _A_P1
   \   00017D                REQUIRE _A_P0
    577          
    578          
    579          
    580          /**************************************************************************************************
    581           * @fn      halGetJoyKeyInput
    582           *
    583           * @brief   Map the ADC value to its corresponding key.
    584           *
    585           * @param   None
    586           *
    587           * @return  keys - current joy key status
    588           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    589          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    590          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    591            /* The joystick control is encoded as an analog voltage.
    592             * Read the JOY_LEVEL analog value and map it to joy movement.
    593             */
    594            uint8 adc;
    595            uint8 ksave0 = 0;
   \   000005   7E00         MOV     R6,#0x0
    596            uint8 ksave1;
    597          
    598            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    599            do
    600            {
    601              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??halGetJoyKeyInput_0:
   \   000007   8E..         MOV     ?V0 + 0,R6
    602          
    603              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000009                ; Setup parameters for call to function HalAdcRead
   \   000009   7A01         MOV     R2,#0x1
   \   00000B   7906         MOV     R1,#0x6
   \   00000D   12....       LCALL   ??HalAdcRead?relay
   \   000010   EA           MOV     A,R2
   \   000011   FF           MOV     R7,A
    604          
    605              if ((adc >= 2) && (adc <= 38))
   \   000012   EF           MOV     A,R7
   \   000013   C3           CLR     C
   \   000014   9402         SUBB    A,#0x2
   \   000016   4006         JC      ??halGetJoyKeyInput_1
   \   000018   EF           MOV     A,R7
   \   000019   C3           CLR     C
   \   00001A   9427         SUBB    A,#0x27
   \   00001C   4022         JC      ??halGetJoyKeyInput_2
    606              {
    607              //   ksave0 |= HAL_KEY_UP;
    608              }
    609              else if ((adc >= 74) && (adc <= 88))
   \                     ??halGetJoyKeyInput_1:
   \   00001E   EF           MOV     A,R7
   \   00001F   C3           CLR     C
   \   000020   944A         SUBB    A,#0x4a
   \   000022   4006         JC      ??halGetJoyKeyInput_3
   \   000024   EF           MOV     A,R7
   \   000025   C3           CLR     C
   \   000026   9459         SUBB    A,#0x59
   \   000028   4016         JC      ??halGetJoyKeyInput_2
    610              {
    611             //   ksave0 |= HAL_KEY_RIGHT;
    612              }
    613              else if ((adc >= 60) && (adc <= 73))
   \                     ??halGetJoyKeyInput_3:
   \   00002A   EF           MOV     A,R7
   \   00002B   C3           CLR     C
   \   00002C   943C         SUBB    A,#0x3c
   \   00002E   4006         JC      ??halGetJoyKeyInput_4
   \   000030   EF           MOV     A,R7
   \   000031   C3           CLR     C
   \   000032   944A         SUBB    A,#0x4a
   \   000034   400A         JC      ??halGetJoyKeyInput_2
    614              {
    615             //   ksave0 |= HAL_KEY_LEFT;
    616              }
    617              else if ((adc >= 39) && (adc <= 59))
   \                     ??halGetJoyKeyInput_4:
   \   000036   EF           MOV     A,R7
   \   000037   C3           CLR     C
   \   000038   9427         SUBB    A,#0x27
   \   00003A   4004         JC      ??halGetJoyKeyInput_2
   \   00003C   EF           MOV     A,R7
   \   00003D   C3           CLR     C
   \   00003E   943C         SUBB    A,#0x3c
    618              {
    619             //   ksave0 |= HAL_KEY_DOWN;
    620              }
    621              else if ((adc >= 89) && (adc <= 100))
    622              {
    623             //   ksave0 |= HAL_KEY_CENTER;
    624              }
    625            } while (ksave0 != ksave1);
   \                     ??halGetJoyKeyInput_2:
   \   000040   E5..         MOV     A,?V0 + 0
   \   000042   6E           XRL     A,R6
   \   000043   70C2         JNZ     ??halGetJoyKeyInput_0
    626          
    627            return ksave0;
   \   000045   EE           MOV     A,R6
   \   000046   F9           MOV     R1,A
   \   000047   7F01         MOV     R7,#0x1
   \   000049   02....       LJMP    ?BANKED_LEAVE_XDATA
    628          }
    629          
    630          
    631          
    632          
    633          
    634          /**************************************************************************************************
    635           * @fn      halProcessKeyInterrupt
    636           *
    637           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    638           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    639           *
    640           * @param
    641           *
    642           * @return
    643           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    644          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    645          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    646            bool valid=FALSE;
   \   000005   7E00         MOV     R6,#0x0
    647            
    648              if (HAL_KEY_SW_1_PXIFG & HAL_KEY_SW_1_BIT)  /* Interrupt Flag has been set */
   \   000007   E58A         MOV     A,0x8a
   \   000009   A2E2         MOV     C,0xE0 /* A   */.2
   \   00000B   5002         JNC     ??halProcessKeyInterrupt_0
    649            {
    650            //  HAL_KEY_SW_1_PXIFG = ~(HAL_KEY_SW_1_BIT); /* Clear Interrupt Flag */
    651              valid = TRUE;
   \   00000D   7E01         MOV     R6,#0x1
    652            }
    653            
    654             
    655              if (HAL_KEY_SW_3_PXIFG & HAL_KEY_SW_3_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   00000F   E58A         MOV     A,0x8a
   \   000011   A2E5         MOV     C,0xE0 /* A   */.5
   \   000013   5002         JNC     ??halProcessKeyInterrupt_1
    656            {
    657            //  HAL_KEY_SW_3_PXIFG = ~(HAL_KEY_SW_3_BIT); /* Clear Interrupt Flag */
    658              valid = TRUE;
   \   000015   7E01         MOV     R6,#0x1
    659            }
    660            
    661              if (HAL_KEY_SW_4_PXIFG & HAL_KEY_SW_4_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_1:
   \   000017   E58A         MOV     A,0x8a
   \   000019   A2E6         MOV     C,0xE0 /* A   */.6
   \   00001B   5002         JNC     ??halProcessKeyInterrupt_2
    662            {
    663            //  HAL_KEY_SW_4_PXIFG = ~(HAL_KEY_SW_4_BIT); /* Clear Interrupt Flag */
    664              valid = TRUE;
   \   00001D   7E01         MOV     R6,#0x1
    665            }
    666            
    667            if (HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_2:
   \   00001F   E58A         MOV     A,0x8a
   \   000021   A2E7         MOV     C,0xE0 /* A   */.7
   \   000023   5002         JNC     ??halProcessKeyInterrupt_3
    668            {
    669            //  HAL_KEY_SW_5_PXIFG = ~(HAL_KEY_SW_5_BIT); /* Clear Interrupt Flag */
    670              valid = TRUE;
   \   000025   7E01         MOV     R6,#0x1
    671            }
    672          
    673            
    674            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_3:
   \   000027   E589         MOV     A,0x89
   \   000029   A2E4         MOV     C,0xE0 /* A   */.4
   \   00002B   5002         JNC     ??halProcessKeyInterrupt_4
    675            {
    676            //  HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
    677              valid = TRUE;
   \   00002D   7E01         MOV     R6,#0x1
    678            }
    679            
    680            
    681          
    682            
    683           
    684          
    685            if (valid)
   \                     ??halProcessKeyInterrupt_4:
   \   00002F   EE           MOV     A,R6
   \   000030   6011         JZ      ??halProcessKeyInterrupt_5
    686            {
    687              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   000032                ; Setup parameters for call to function osal_start_timerEx
   \   000032   7C19         MOV     R4,#0x19
   \   000034   7D00         MOV     R5,#0x0
   \   000036   7A01         MOV     R2,#0x1
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   90....       MOV     DPTR,#Hal_TaskID
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   12....       LCALL   ??osal_start_timerEx?relay
   \   000042   E9           MOV     A,R1
    688            }
    689          }
   \                     ??halProcessKeyInterrupt_5:
   \   000043   7F01         MOV     R7,#0x1
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000048                REQUIRE P1IFG
   \   000048                REQUIRE P0IFG
    690          
    691          /**************************************************************************************************
    692           * @fn      HalKeyEnterSleep
    693           *
    694           * @brief  - Get called to enter sleep mode
    695           *
    696           * @param
    697           *
    698           * @return
    699           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    700          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    701          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    702          }
   \   000000   02....       LJMP    ?BRET
    703          
    704          /**************************************************************************************************
    705           * @fn      HalKeyExitSleep
    706           *
    707           * @brief   - Get called when sleep is over
    708           *
    709           * @param
    710           *
    711           * @return  - return saved keys
    712           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    713          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    714          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    715            /* Wake up and read keys */
    716            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    717          }
    718          
    719          /***************************************************************************************************
    720           *                                    INTERRUPT SERVICE ROUTINE
    721           ***************************************************************************************************/
    722          
    723          /**************************************************************************************************
    724           * @fn      halKeyPort0Isr
    725           *
    726           * @brief   Port0 ISR
    727           *
    728           * @param
    729           *
    730           * @return
    731           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    732          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    733          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    734            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    735            
    736           PCON = 0x00;//唤醒
   \   00000E   758700       MOV     0x87,#0x0
    737             if(HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
   \   000011   E589         MOV     A,0x89
   \   000013   A2E4         MOV     C,0xE0 /* A   */.4
   \   000015   500A         JNC     ??halKeyPort0Isr_0
    738            {
    739              //  HalLedBlink ( HAL_LED_2, 2, 50, 500 );
    740              
    741              halProcessKeyInterrupt();
   \   000017                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000017   12....       LCALL   ??halProcessKeyInterrupt?relay
    742             // key_ISR_FLAG =HAL_KEY_SW_6;
    743              key_ISR_FLAG |=HAL_KEY_SW_6;
   \   00001A   90....       MOV     DPTR,#key_ISR_FLAG
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   D2E5         SETB    0xE0 /* A   */.5
   \   000020   F0           MOVX    @DPTR,A
    744            //  HAL_KEY_SW_6_PXIFG = 0;
    745            }
    746          
    747            P0IFG =0;
   \                     ??halKeyPort0Isr_0:
   \   000021   758900       MOV     0x89,#0x0
    748            HAL_KEY_CPU_PORT_0_IF = 0;
   \   000024   C2C5         CLR     0xc0.5
    749            
    750           // osal_start_timerEx( SampleApp_TaskID,OS_TEST_EVT,15000 );
    751          
    752            CLEAR_SLEEP_MODE();
   \   000026   75..00       MOV     halSleepPconValue,#0x0
    753            HAL_EXIT_ISR();
   \   000029   EE           MOV     A,R6
   \   00002A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00002C   92AF         MOV     0xa8.7,C
    754          }
   \   00002E   7F01         MOV     R7,#0x1
   \   000030   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000033                REQUIRE _A_IEN0
   \   000033                REQUIRE PCON
   \   000033                REQUIRE P0IFG
   \   000033                REQUIRE _A_IRCON
    755          
    756          
    757          /**************************************************************************************************
    758           * @fn      halKeyPort1Isr
    759           *
    760           * @brief   Port1 ISR
    761           *
    762           * @param
    763           *
    764           * @return
    765           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    766          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
   \                     halKeyPort1Isr:
    767          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    768            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    769          
    770           PCON = 0x00;//唤醒
   \   00000E   758700       MOV     0x87,#0x0
    771            // ZDApp_AnnounceNewAddress();
    772             
    773             if(HAL_KEY_SW_1_PXIFG & HAL_KEY_SW_1_BIT)
   \   000011   E58A         MOV     A,0x8a
   \   000013   A2E2         MOV     C,0xE0 /* A   */.2
   \   000015   5011         JNC     ??halKeyPort1Isr_0
    774            {
    775              P1_2_FLAG++;
   \   000017   90....       MOV     DPTR,#P1_2_FLAG
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   2401         ADD     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
    776            //  HalLedBlink ( HAL_LED_2, 6, 50, 500 );
    777              halProcessKeyInterrupt();
   \   00001E                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00001E   12....       LCALL   ??halProcessKeyInterrupt?relay
    778             // key_ISR_FLAG =HAL_KEY_SW_1;
    779              key_ISR_FLAG |=HAL_KEY_SW_1;
   \   000021   90....       MOV     DPTR,#key_ISR_FLAG
   \   000024   E0           MOVX    A,@DPTR
   \   000025   D2E0         SETB    0xE0 /* A   */.0
   \   000027   F0           MOVX    @DPTR,A
    780             // HAL_KEY_SW_1_PXIFG = 0;
    781          
    782            }
    783          
    784          
    785                if(HAL_KEY_SW_3_PXIFG & HAL_KEY_SW_3_BIT)
   \                     ??halKeyPort1Isr_0:
   \   000028   E58A         MOV     A,0x8a
   \   00002A   A2E5         MOV     C,0xE0 /* A   */.5
   \   00002C   500A         JNC     ??halKeyPort1Isr_1
    786            {
    787             
    788             // HalLedBlink ( HAL_LED_2, 10, 50, 500 );
    789              halProcessKeyInterrupt();
   \   00002E                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00002E   12....       LCALL   ??halProcessKeyInterrupt?relay
    790            //  key_ISR_FLAG =HAL_KEY_SW_9;
    791              key_ISR_FLAG |=HAL_KEY_SW_9;
   \   000031   90....       MOV     DPTR,#key_ISR_FLAG
   \   000034   E0           MOVX    A,@DPTR
   \   000035   D2E6         SETB    0xE0 /* A   */.6
   \   000037   F0           MOVX    @DPTR,A
    792           //   HAL_KEY_SW_3_PXIFG = 0;
    793            }
    794            
    795                if(HAL_KEY_SW_4_PXIFG & HAL_KEY_SW_4_BIT)
   \                     ??halKeyPort1Isr_1:
   \   000038   E58A         MOV     A,0x8a
   \   00003A   A2E6         MOV     C,0xE0 /* A   */.6
   \   00003C   500A         JNC     ??halKeyPort1Isr_2
    796            {
    797              
    798             //   HalLedBlink ( HAL_LED_2, 12, 50, 500 );
    799              halProcessKeyInterrupt();
   \   00003E                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00003E   12....       LCALL   ??halProcessKeyInterrupt?relay
    800             // key_ISR_FLAG =HAL_KEY_SW_4;
    801              key_ISR_FLAG |=HAL_KEY_SW_4;
   \   000041   90....       MOV     DPTR,#key_ISR_FLAG
   \   000044   E0           MOVX    A,@DPTR
   \   000045   D2E3         SETB    0xE0 /* A   */.3
   \   000047   F0           MOVX    @DPTR,A
    802            //  HAL_KEY_SW_4_PXIFG = 0;
    803            }
    804            
    805                if(HAL_KEY_SW_5_PXIFG & HAL_KEY_SW_5_BIT)
   \                     ??halKeyPort1Isr_2:
   \   000048   E58A         MOV     A,0x8a
   \   00004A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00004C   500A         JNC     ??halKeyPort1Isr_3
    806            {
    807             
    808             //  HalLedBlink ( HAL_LED_2, 14, 50, 500 );
    809              halProcessKeyInterrupt();
   \   00004E                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00004E   12....       LCALL   ??halProcessKeyInterrupt?relay
    810             // key_ISR_FLAG =HAL_KEY_SW_5;
    811              key_ISR_FLAG |=HAL_KEY_SW_5;
   \   000051   90....       MOV     DPTR,#key_ISR_FLAG
   \   000054   E0           MOVX    A,@DPTR
   \   000055   D2E2         SETB    0xE0 /* A   */.2
   \   000057   F0           MOVX    @DPTR,A
    812            //  HAL_KEY_SW_5_PXIFG = 0;
    813            }
    814            
    815            P1IFG = 0;
   \                     ??halKeyPort1Isr_3:
   \   000058   758A00       MOV     0x8a,#0x0
    816            HAL_KEY_CPU_PORT_1_IF = 0;
   \   00005B   C2EB         CLR     0xe8.3
    817          
    818           // NLME_RouteDiscoveryRequest( 0, 0, 0 ); 
    819           // osal_start_timerEx( SampleApp_TaskID,OS_TEST_EVT,15000 );
    820            CLEAR_SLEEP_MODE();
   \   00005D   75..00       MOV     halSleepPconValue,#0x0
    821            HAL_EXIT_ISR();
   \   000060   EE           MOV     A,R6
   \   000061   A2E0         MOV     C,0xE0 /* A   */.0
   \   000063   92AF         MOV     0xa8.7,C
    822            
    823          }
   \   000065   7F01         MOV     R7,#0x1
   \   000067   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00006A                REQUIRE _A_IEN0
   \   00006A                REQUIRE PCON
   \   00006A                REQUIRE P1IFG
   \   00006A                REQUIRE _A_IRCON2
    824          
    825          
    826          
    827          
    828          /**************************************************************************************************
    829           * @fn      halKeyPort2Isr
    830           *
    831           * @brief   Port2 ISR
    832           *
    833           * @param
    834           *
    835           * @return
    836           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    837          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    838          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007                ; Saved register size: 3
   \   000007                ; Auto size: 0
    839            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   F8           MOV     R0,A
   \   00000C   D2AF         SETB    0xa8.7
    840            
    841          
    842          
    843            CLEAR_SLEEP_MODE();
   \   00000E   75..00       MOV     halSleepPconValue,#0x0
    844            HAL_EXIT_ISR();
   \   000011   A2E0         MOV     C,0xE0 /* A   */.0
   \   000013   92AF         MOV     0xa8.7,C
    845          }
   \   000015   D0E0         POP     A
   \   000017   F8           MOV     R0,A
   \   000018   D0D0         POP     PSW
   \   00001A   D0E0         POP     A
   \   00001C   32           RETI
   \   00001D                REQUIRE _A_IEN0

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halKeyPort1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halKeyPort1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetJoyKeyInput?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    846          
    847          
    848          
    849          #else
    850          
    851          void Key_Check(void){}
    852          void HalKeyInit(void){}
    853          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    854          uint8 HalKeyRead(void){ return 0;}
    855          void HalKeyPoll(void){}
    856          void HalKey_double_detect(void);
    857          #endif /* HAL_KEY */
    858          
    859          
    860          
    861          /**************************************************************************************************
    862          **************************************************************************************************/
    863          
    864          
    865          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     HalKeyConfig                       0      0      9
       -> osal_stop_timerEx             0      0     18
       -> osal_set_event                0      0     18
     HalKeyEnterSleep                   0      0      0
     HalKeyExitSleep                    2      0      0
       -> HalKeyRead                    4      0      0
     HalKeyInit                         2      0      0
     HalKeyPoll                         0      0      9
       -> SampleAPP_send_delay_message
                                        0      0     18
       -> SampleAPP_send_delay_message
                                        0      0     18
       -> SampleAPP_send_delay_message
                                        0      0     18
       -> SampleAPP_send_delay_message
                                        0      0     18
       -> osal_stop_timerEx             0      0     18
       -> osal_stop_timerEx             0      0     18
       -> osal_start_timerEx            0      0     18
     HalKeyRead                         0      0      0
     halGetJoyKeyInput                  0      0      9
       -> HalAdcRead                    0      0     18
     halKeyPort0Isr                    15      0      0
       -> halProcessKeyInterrupt       30      0      0
     halKeyPort1Isr                    15      0      0
       -> halProcessKeyInterrupt       30      0      0
       -> halProcessKeyInterrupt       30      0      0
       -> halProcessKeyInterrupt       30      0      0
       -> halProcessKeyInterrupt       30      0      0
     halKeyPort2Isr                     3      0      0
     halProcessKeyInterrupt             0      0      9
       -> osal_start_timerEx            0      0     18


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     PCON                              1
     P0IFG                             1
     P1IFG                             1
     PICTL                             1
     P1IEN                             1
     _A_P1                             1
     IEN2                              1
     _A_IEN0                           1
     P0IEN                             1
     _A_IEN1                           1
     _A_IRCON                          1
     _A_IRCON2                         1
     P0SEL                             1
     P1SEL                             1
     P0DIR                             1
     P1DIR                             1
     halKeySavedKeys                   1
     pHalKeyProcessFunction            2
     HalKeyConfigured                  1
     Hal_KeyIntEnable                  1
     key_press_zdo_flag                1
     kpush0                            1
     kpush1                            1
     key_ISR_FLAG                      1
     key_p1_2_ISR_FLAG                 1
     key_double_flag                   1
     KEY_NET_ISR_FLAG                  1
     key_holdtime_waiting_flag         1
     key_hold_flag                     1
     zdo_start_flag                    1
     P1_2_FLAG                         1
     HalKeyInit                       63
     HalKeyConfig                    157
     HalKeyRead                       14
     HalKeyPoll                      381
     halGetJoyKeyInput                76
     halProcessKeyInterrupt           72
     HalKeyEnterSleep                  3
     HalKeyExitSleep                  14
     halKeyPort0Isr                   51
     halKeyPort1Isr                  106
     halKeyPort2Isr                   29
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??halKeyPort1Isr??INTVEC 123      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halGetJoyKeyInput?relay         6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 780 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
 186 bytes in segment NEAR_CODE
  17 bytes in segment SFR_AN
  16 bytes in segment XDATA_Z
 
 1 014 bytes of CODE  memory (+  9 bytes shared)
     0 bytes of DATA  memory (+ 17 bytes shared)
    16 bytes of XDATA memory

Errors: none
Warnings: 1
