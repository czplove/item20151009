###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         12/Feb/2015  21:25:59 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\Source\LN_2_SCEEN_KEYPAD_devic #
#                          e\LN_2_SCEEN_KEYPAD_key.c                          #
#    Command line       =  -f "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\z #
#                          stack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wRouter.cfg" (-DCPU32MHZ                  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC253 #
#                          0DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=1         #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=60            #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=30           #
#                          -DNWK_MAX_BINDING_ENTRIES=10                       #
#                          -DMAX_BINDING_CLUSTER_IDS=4 -DASSERT_RESET         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=8000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=1000)  #
#                          -DREJOIN_POLL_RATE=440 "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\Source #
#                          \LN_2_SCEEN_KEYPAD_device\LN_2_SCEEN_KEYPAD_key.c" #
#                           -D NV_INIT -D NV_RESTORE -D HOLD_AUTO_START -D    #
#                          MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D           #
#                          MT_ZDO_FUNC -D MT_ZDO_MGMT -D ISR_KEYINTERRUPT -D  #
#                          WDT_IN_PM1 -D OSC32K_CRYSTAL_INSTALLED=0 -D        #
#                          xLARGER_NETWORK -D xNO_32768_XOSC -D POWER_PA -D   #
#                          xEN_WALL_SOKET -D LN_2_SCEEN_KEYPAD -lC            #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\LN_2_SCEEN_KEYPAD\Li #
#                          st\" -lA "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\LN_2_SCEEN_ #
#                          KEYPAD\List\" --diag_suppress Pe001,Pa010 -o       #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\LN_2_SCEEN_KEYPAD\Ob #
#                          j\" -e --no_cse --no_unroll --no_inline            #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\Source\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\Source\LN_2_S #
#                          CEEN_KEYPAD_device\" -I "D:\RE_1_2_0_FORMAL_APP(25 #
#                          1)-14-12-8\Projects\zstack\Samples\SampleApp\CC253 #
#                          0DB\..\..\..\ZMain\TI2530DB\" -I                   #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\hal\include\" -I "D:\RE_1_2_0_FORMAL_APP(251 #
#                          )-14-12-8\Projects\zstack\Samples\SampleApp\CC2530 #
#                          DB\..\..\..\..\..\Components\hal\target\CC2530EB\" #
#                           -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\C #
#                          omponents\mac\include\" -I                         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\high_level\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\" -I                     #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mac\low_level\srf04\single_chip\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\mt\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8 #
#                          \Projects\zstack\Samples\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\osal\include\" -I              #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\saddr\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\services\sdata\" -I                          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\af\" -I "D:\RE_1_2_0_FORMAL_APP(251)-1 #
#                          4-12-8\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\..\..\..\..\Components\stack\nwk\" -I           #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sapi\" -I "D:\RE_1_2_0_FORMAL_APP(251) #
#                          -14-12-8\Projects\zstack\Samples\SampleApp\CC2530D #
#                          B\..\..\..\..\..\Components\stack\sec\" -I         #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\stack\sys\" -I "D:\RE_1_2_0_FORMAL_APP(251)- #
#                          14-12-8\Projects\zstack\Samples\SampleApp\CC2530DB #
#                          \..\..\..\..\..\Components\stack\zdo\" -I          #
#                          "D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zsta #
#                          ck\Samples\SampleApp\CC2530DB\..\..\..\..\..\Compo #
#                          nents\zmac\" -I "D:\RE_1_2_0_FORMAL_APP(251)-14-12 #
#                          -8\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\zmac\f8w\" -On               #
#                          --require_prototypes                               #
#    List file          =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\LN_2_SCEEN_KEYPAD\Lis #
#                          t\LN_2_SCEEN_KEYPAD_key.lst                        #
#    Object file        =  D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstac #
#                          k\Samples\SampleApp\CC2530DB\LN_2_SCEEN_KEYPAD\Obj #
#                          \LN_2_SCEEN_KEYPAD_key.r51                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\RE_1_2_0_FORMAL_APP(251)-14-12-8\Projects\zstack\Samples\SampleApp\Source\LN_2_SCEEN_KEYPAD_device\LN_2_SCEEN_KEYPAD_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          /*
     84          #include "hal_mcu.h"
     85          #include "hal_defs.h"
     86          #include "hal_types.h"
     87          #include "hal_board.h"
     88          #include "hal_drivers.h"
     89          #include "hal_adc.h"
     90          #include "hal_key.h"
     91          #include "osal.h"
     92          #include "hal_led.h"
     93          #include "ZDApp.h"
     94          #include "device.h"
     95          #include "IO_config.h"
     96          //#include "ZDO_LIB.h"
     97          #include "ZDObject.h"
     98          #include "common_device.h"
     99          */
    100          
    101          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x8a
   \   unsigned char volatile __sfr P1IFG
   \                     P1IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
    102          #include "hal_defs.h"
    103          #include "hal_types.h"
    104          #include "hal_board.h"
    105          #include "hal_drivers.h"
    106          #include "hal_adc.h"
    107          #include "hal_key.h"
    108          #include "osal.h"
    109          #include "IO_config.h"
    110          #include "common_device.h"
    111          #include "device.h"
    112          #include "ZDObject.h"
    113          
    114          
    115          
    116          
    117          extern void Delay_1u(uint32 microSecs); 
    118          
    119          extern void SampleAPP_send_delay_message(void);
    120          extern uint8 zdoDiscCounter;
    121          
    122          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    123          
    124          /**************************************************************************************************
    125           *                                              MACROS
    126           **************************************************************************************************/
    127          
    128          /**************************************************************************************************
    129           *                                            CONSTANTS
    130           **************************************************************************************************/
    131          #define HAL_KEY_RISING_EDGE   0
    132          #define HAL_KEY_FALLING_EDGE  1
    133          
    134          #define HAL_KEY_DEBOUNCE_VALUE  50
    135          #define HAL_KEY_CLICKED_VALUE  600  //600ms 内没按键中断则按键检测结束，发送检测到的按键次数到应用层
    136          #define HAL_KEY_HOLD_VALUE  9400    //9.4s  按键长按10s（9.4s+600ms）以后判断为长按按钮操作
    137          #define HAL_KEY_DOBULETICK_VALUE   1000
    138          /* CPU port interrupt */
    139          #define HAL_KEY_CPU_PORT_0_IF P0IF
    140          #define HAL_KEY_CPU_PORT_1_IF P1IF
    141          #define HAL_KEY_CPU_PORT_2_IF P2IF
    142          
    143          
    144          /* SW_6 is at P1.2 */
    145          #define HAL_KEY_SW_7_PORT   P1
    146          #define HAL_KEY_SW_7_BIT    BV(2)
    147          #define HAL_KEY_SW_7_SEL    P1SEL
    148          #define HAL_KEY_SW_7_DIR    P1DIR
    149          /* edge interrupt */
    150          #define HAL_KEY_SW_7_EDGEBIT  BV(1)
    151          #define HAL_KEY_SW_7_EDGE     HAL_KEY_FALLING_EDGE
    152          /* SW_6 interrupts */
    153          #define HAL_KEY_SW_7_IEN      IEN2  /* CPU interrupt mask register */
    154          #define HAL_KEY_SW_7_IENBIT   BV(1) /* Mask bit for all of Port_0 */
    155          #define HAL_KEY_SW_7_ICTL     P1IEN /* Port Interrupt Control register */
    156          #define HAL_KEY_SW_7_ICTLBIT  BV(2) /* P0IEN - P0.1 enable/disable bit BV(1)*/
    157          #define HAL_KEY_SW_7_PXIFG    P1IFG /* Interrupt flag at source */
    158          
    159          
    160          /* SW_8 is at P1.0 */
    161          #define HAL_KEY_SW_9_PORT   P1
    162          #define HAL_KEY_SW_9_BIT    BV(0)
    163          #define HAL_KEY_SW_9_SEL    P1SEL
    164          #define HAL_KEY_SW_9_DIR    P1DIR
    165          /* edge interrupt */
    166          #define HAL_KEY_SW_9_EDGEBIT  BV(1)//p1端口的触发模式设置 在PICTL的低第二位（位1）
    167          #define HAL_KEY_SW_9_EDGE     HAL_KEY_FALLING_EDGE  // 
    168          /* SW_8 interrupts */
    169          #define HAL_KEY_SW_9_IEN      IEN2  /* CPU interrupt mask register */
    170          #define HAL_KEY_SW_9_IENBIT   BV(4) /* Mask bit for all of Port_1 */
    171          #define HAL_KEY_SW_9_ICTL     P1IEN /* Port Interrupt Control register */
    172          #define HAL_KEY_SW_9_ICTLBIT  BV(0) /* P1IEN - P1.2 enable/disable bit */ 
    173          #define HAL_KEY_SW_9_PXIFG    P1IFG /* Interrupt flag at source */
    174          
    175          
    176          /* SW_9 is at P1.7 */
    177          #define HAL_KEY_SW_8_PORT   P1
    178          #define HAL_KEY_SW_8_BIT    BV(7)
    179          #define HAL_KEY_SW_8_SEL    P1SEL
    180          #define HAL_KEY_SW_8_DIR    P1DIR
    181          /* edge interrupt */
    182          #define HAL_KEY_SW_8_EDGEBIT  BV(2)//p1端口的触发模式设置 在PICTL的低第三位（位2）P1.5为高4位地址
    183          #define HAL_KEY_SW_8_EDGE     HAL_KEY_FALLING_EDGE  // 
    184          /* SW_9 interrupts */
    185          #define HAL_KEY_SW_8_IEN      IEN2  /* CPU interrupt mask register */
    186          #define HAL_KEY_SW_8_IENBIT   BV(4) /* Mask bit for all of Port_1 */
    187          #define HAL_KEY_SW_8_ICTL     P1IEN /* Port Interrupt Control register */
    188          #define HAL_KEY_SW_8_ICTLBIT  BV(7) /* P1IEN - P1.4 enable/disable bit */ 
    189          #define HAL_KEY_SW_8_PXIFG    P1IFG /* Interrupt flag at source */
    190          
    191          
    192          
    193          #define KEY_FORBITON_TIME   300
    194          
    195          /**************************************************************************************************
    196           *                                            TYPEDEFS
    197           **************************************************************************************************/
    198          
    199          
    200          /**************************************************************************************************
    201           *                                        GLOBAL VARIABLES
    202           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204           halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    205          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    206          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    207          
    208          /**************************************************************************************************
    209           *                                        FUNCTIONS - Local
    210           **************************************************************************************************/
    211          void halProcessKeyInterrupt(void);
    212          uint8 halGetJoyKeyInput(void);

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    213          uint8 kpush0=0;
   \                     kpush0:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    214          uint8 kpush1=0;
   \                     kpush1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    215          uint8 key_ISR_FLAG=0;
   \                     key_ISR_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    216          uint8 KEY_NET_ISR_FLAG=0;//test p1.2口的单击 双击
   \                     KEY_NET_ISR_FLAG:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    217          uint8 key_double_flag = 0;//按键双击状态
   \                     key_double_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    218          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    219          uint8 key_holdtime_waiting_flag = 0;//等待长按时间（10s）标志 ，0无等待 1正在等待
   \                     key_holdtime_waiting_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    220          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    221          uint8 key_hold_flag = 0;  //按键长按标志
   \                     key_hold_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    222          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    223          uint8 Forbitten_ON_flag=0;
   \                     Forbitten_ON_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    224          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    225          uint8 KEY_NUMBER_FLAG_A = 0;//按键标志
   \                     KEY_NUMBER_FLAG_A:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    226          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    227          uint8 key_press_zdo_flag=0;
   \                     key_press_zdo_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    228          
    229          
    230          extern uint8 screen_current_flag;
    231          
    232          extern uint8 screen_flag;
    233          
    234          /**************************************************************************************************
    235           *                                        FUNCTIONS - API
    236           **************************************************************************************************/
    237          
    238          
    239          /**************************************************************************************************
    240           * @fn      HalKeyInit
    241           *
    242           * @brief   Initilize Key Service
    243           *
    244           * @param   none
    245           *
    246           * @return  None
    247           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          void HalKeyInit( void )
   \                     HalKeyInit:
    249          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    250            /* Initialize previous key to 0 */
    251            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    252            
    253            
    254            HAL_KEY_SW_7_SEL &= ~(HAL_KEY_SW_7_BIT);    /* Set pin function to GPIO */
   \   00000A   53F4FB       ANL     0xf4,#0xfb
    255            HAL_KEY_SW_7_DIR &= ~(HAL_KEY_SW_7_BIT);    /* Set pin direction to Input */
   \   00000D   53FEFB       ANL     0xfe,#0xfb
    256            
    257            HAL_KEY_SW_8_SEL &= ~(HAL_KEY_SW_8_BIT);    /* Set pin function to GPIO */
   \   000010   53F47F       ANL     0xf4,#0x7f
    258            HAL_KEY_SW_8_DIR &= ~(HAL_KEY_SW_8_BIT);    /* Set pin direction to Input */
   \   000013   53FE7F       ANL     0xfe,#0x7f
    259            
    260            HAL_KEY_SW_9_SEL &= ~(HAL_KEY_SW_9_BIT);    /* Set pin function to GPIO */
   \   000016   53F4FE       ANL     0xf4,#0xfe
    261            HAL_KEY_SW_9_DIR &= ~(HAL_KEY_SW_9_BIT);    /* Set pin direction to Input */
   \   000019   53FEFE       ANL     0xfe,#0xfe
    262          
    263          
    264            /* Initialize callback function */
    265            pHalKeyProcessFunction  = NULL;
   \   00001C   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00001F   7400         MOV     A,#0x0
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   7400         MOV     A,#0x0
   \   000025   F0           MOVX    @DPTR,A
    266          
    267            /* Start with key is not configured */
    268            HalKeyConfigured = FALSE;
   \   000026   90....       MOV     DPTR,#HalKeyConfigured
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
    269          }
   \   00002C   D083         POP     DPH
   \   00002E   D082         POP     DPL
   \   000030   02....       LJMP    ?BRET
   \   000033                REQUIRE P1SEL
   \   000033                REQUIRE P1DIR
    270          
    271          
    272          /**************************************************************************************************
    273           * @fn      HalKeyConfig
    274           *
    275           * @brief   Configure the Key serivce
    276           *
    277           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    278           *          cback - pointer to the CallBack function
    279           *
    280           * @return  None
    281           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    282          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    283          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    284            /* Enable/Disable Interrupt or */
    285            Hal_KeyIntEnable = interruptEnable;
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000010   F0           MOVX    @DPTR,A
    286          
    287            /* Register the callback fucntion */
    288            pHalKeyProcessFunction = cback;
   \   000011   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000014   EE           MOV     A,R6
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   EF           MOV     A,R7
   \   000018   F0           MOVX    @DPTR,A
    289          
    290            /* Determine if interrupt is enable or not */
    291            if (Hal_KeyIntEnable)
   \   000019   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6042         JZ      ??HalKeyConfig_0
    292            {
    293                /* Rising/Falling edge configuratinn */
    294          
    295             
    296              
    297              //P1.2
    298              PICTL &= ~(HAL_KEY_SW_7_EDGEBIT);    /* Clear the edge bit */
   \   00001F   538CFD       ANL     0x8c,#0xfd
    299              /* For falling edge, the bit must be set. */
    300            #if (HAL_KEY_SW_7_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    301              PICTL |= HAL_KEY_SW_7_EDGEBIT;
   \   000022   438C02       ORL     0x8c,#0x2
    302            #endif
    303              HAL_KEY_SW_7_ICTL |= HAL_KEY_SW_7_ICTLBIT;//P0IEN | 00010000  即P0.4使能中断
   \   000025   438D04       ORL     0x8d,#0x4
    304              HAL_KEY_SW_7_IEN |= HAL_KEY_SW_7_IENBIT;//使能整个CPU的P0口中断
   \   000028   439A02       ORL     0x9a,#0x2
    305              HAL_KEY_SW_7_PXIFG &= ~(HAL_KEY_SW_7_BIT);//清中断标记位
   \   00002B   538AFB       ANL     0x8a,#0xfb
    306              
    307              //P1.8
    308               PICTL &= ~(HAL_KEY_SW_8_EDGEBIT);    /* Clear the edge bit */
   \   00002E   538CFB       ANL     0x8c,#0xfb
    309              /* For falling edge, the bit must be set. */
    310            #if (HAL_KEY_SW_8_EDGE == HAL_KEY_FALLING_EDGE)
    311              PICTL |= HAL_KEY_SW_8_EDGEBIT;			//P1.0~p1.3下降沿 。p1.2 按键下降沿
   \   000031   438C04       ORL     0x8c,#0x4
    312            #endif
    313              HAL_KEY_SW_8_ICTL |= HAL_KEY_SW_8_ICTLBIT;//P1IEN | 00000100  即P1.2使能中断
   \   000034   438D80       ORL     0x8d,#0x80
    314              HAL_KEY_SW_8_IEN |= HAL_KEY_SW_8_IENBIT;//使能整个CPU的P1口中断
   \   000037   439A10       ORL     0x9a,#0x10
    315              HAL_KEY_SW_8_PXIFG &= ~(HAL_KEY_SW_8_BIT);//清中断标记位
   \   00003A   538A7F       ANL     0x8a,#0x7f
    316             
    317              
    318          
    319          //P1.0
    320               PICTL &= ~(HAL_KEY_SW_9_EDGEBIT);    /* Clear the edge bit */
   \   00003D   538CFD       ANL     0x8c,#0xfd
    321              /* For falling edge, the bit must be set. */
    322            #if (HAL_KEY_SW_9_EDGE == HAL_KEY_FALLING_EDGE)//2530的上升 下降沿触发是按端口设置的，即P0要么是上升要么全是下降
    323              PICTL |= HAL_KEY_SW_9_EDGEBIT;
   \   000040   438C02       ORL     0x8c,#0x2
    324            #endif
    325              HAL_KEY_SW_9_ICTL |= HAL_KEY_SW_9_ICTLBIT;//P1IEN | 00100000  即P1.5使能中断
   \   000043   438D01       ORL     0x8d,#0x1
    326              HAL_KEY_SW_9_IEN |= HAL_KEY_SW_9_IENBIT;//使能整个CPU的P1口中断
   \   000046   439A10       ORL     0x9a,#0x10
    327              HAL_KEY_SW_9_PXIFG &= ~(HAL_KEY_SW_9_BIT);//清中断标记位
   \   000049   538AFE       ANL     0x8a,#0xfe
    328              
    329          
    330              /* Do this only after the hal_key is configured - to work with sleep stuff */
    331              if (HalKeyConfigured == TRUE)
   \   00004C   90....       MOV     DPTR,#HalKeyConfigured
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   6401         XRL     A,#0x1
   \   000052   700D         JNZ     ??HalKeyConfig_0
    332              {
    333                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   000054                ; Setup parameters for call to function osal_stop_timerEx
   \   000054   7A01         MOV     R2,#0x1
   \   000056   7B00         MOV     R3,#0x0
   \   000058   90....       MOV     DPTR,#Hal_TaskID
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??osal_stop_timerEx?relay
   \   000060   E9           MOV     A,R1
    334              }
    335            }
    336            else    /* Interrupts NOT enabled */
    337            {
    338              
    339              
    340            }
    341          
    342            /* Key now is configured */
    343            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_0:
   \   000061   90....       MOV     DPTR,#HalKeyConfigured
   \   000064   7401         MOV     A,#0x1
   \   000066   F0           MOVX    @DPTR,A
    344          }
   \   000067   7F01         MOV     R7,#0x1
   \   000069   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00006C                REQUIRE PICTL
   \   00006C                REQUIRE P1IEN
   \   00006C                REQUIRE IEN2
   \   00006C                REQUIRE P1IFG
    345          
    346          
    347          /**************************************************************************************************
    348           * @fn      HalKeyRead
    349           *
    350           * @brief   Read the current value of a key
    351           *
    352           * @param   None
    353           *
    354           * @return  keys - current keys status
    355           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    356          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    357          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    358            uint8 keys = 0;
   \   000000   7900         MOV     R1,#0x0
    359          
    360            if (HAL_PUSH_BUTTON1())
   \   000002   A293         MOV     C,0x90.3
   \   000004   5005         JNC     ??HalKeyRead_0
    361            {
    362              keys |= HAL_KEY_SW_6;
   \   000006   D3           SETB    C
   \   000007   E9           MOV     A,R1
   \   000008   92E5         MOV     0xE0 /* A   */.5,C
   \   00000A   F9           MOV     R1,A
    363            }
    364          
    365            
    366          
    367            return keys;
   \                     ??HalKeyRead_0:
   \   00000B   02....       LJMP    ?BRET
   \   00000E                REQUIRE _A_P1
    368          }
    369          
    370          
    371          /**************************************************************************************************
    372           * @fn      HalKeyPoll
    373           *
    374           * @brief   Called by hal_driver to poll the keys
    375           *
    376           * @param   None
    377           *
    378           * @return  None
    379          
    380          对应关系：
    381          P1.2 HAL_PUSH_BUTTON3 左边第一个按键 HAL_KEY_SW_8_PXIFG   HAL_KEY_SW_8 对应左边第一个灯 LED1 P1.0 key_other2_present_flag
    382          P1.5 HAL_PUSH_BUTTON2 中间按键      HAL_KEY_SW_7_PXIFG   HAL_KEY_SW_7 对应左边中间灯  LED2    P0.6 key_other3_present_flag
    383          P1.6 HAL_PUSH_BUTTON1 右边最后一个按键      HAL_KEY_SW_6_PXIFG   HAL_KEY_SW_6 对应右边灯  LED3 P0.5 key_other4_present_flag
    384          P1.7 HAL_PUSH_BUTTON5 系统内置按键      HAL_KEY_SW_9_PXIFG   HAL_KEY_SW_9 对应右边灯  LED5     P2.0 key_other1_present_flag
    385          
    386          
    387            
    388          
    389           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    390          void HalKeyPoll (void)
   \                     HalKeyPoll:
    391          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    392           uint8 keys = 0;
   \   000005   7E00         MOV     R6,#0x0
    393          
    394            
    395          
    396            /* If interrupts are not enabled, previous key status and current key status
    397             * are compared to find out if a key has changed status.
    398             */
    399            if (!Hal_KeyIntEnable)
   \   000007   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   7012         JNZ     ??HalKeyPoll_0
    400            {
    401              if (keys == halKeySavedKeys)
   \   00000D   90....       MOV     DPTR,#halKeySavedKeys
   \   000010   E0           MOVX    A,@DPTR
   \   000011   6E           XRL     A,R6
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??HalKeyPoll_1 & 0xFFFF
    402              {
    403                 /* Exit - since no keys have changed */
    404                return;
    405              }
    406              /* Store the current keys for comparation next time */
    407              halKeySavedKeys = keys;
   \   000017   EE           MOV     A,R6
   \   000018   90....       MOV     DPTR,#halKeySavedKeys
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   02....       LJMP    ??HalKeyPoll_2 & 0xFFFF
    408            }
    409            else
    410            {
    411              /* Key interrupt handled here */
    412          
    413              
    414              //P1.2   为系统设置按钮 对应的指示灯位 P2.0
    415                if ((key_ISR_FLAG==HAL_KEY_SW_8) && (!(HAL_PUSH_BUTTON3())))//初步理解，设置p1.2为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
   \                     ??HalKeyPoll_0:
   \   00001F   90....       MOV     DPTR,#key_ISR_FLAG
   \   000022   E0           MOVX    A,@DPTR
   \   000023   6480         XRL     A,#0x80
   \   000025   704A         JNZ     ??HalKeyPoll_3
   \   000027   A297         MOV     C,0x90.7
   \   000029   4046         JC      ??HalKeyPoll_3
    416             {
    417               
    418               
    419               if(key_holdtime_waiting_flag)
   \   00002B   90....       MOV     DPTR,#key_holdtime_waiting_flag
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6019         JZ      ??HalKeyPoll_4
    420          	 {
    421          	   key_holdtime_waiting_flag = 0;//在等待长按时间时再次按下按钮 此时需要清等待长按时间标志以及取消之前设置的等待长按时间满以后进入事件
   \   000031   90....       MOV     DPTR,#key_holdtime_waiting_flag
   \   000034   7400         MOV     A,#0x0
   \   000036   F0           MOVX    @DPTR,A
    422          	   osal_stop_timerEx (Hal_TaskID, HAL_KEY_HOLD_EVENT);//  停止之前进入的事件
   \   000037                ; Setup parameters for call to function osal_stop_timerEx
   \   000037   7A40         MOV     R2,#0x40
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#Hal_TaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   12....       LCALL   ??osal_stop_timerEx?relay
   \   000043   E9           MOV     A,R1
    423          	   KEY_NET_ISR_FLAG = 0;// 等待长按时间被打断后 重新计数按键次数
   \   000044   90....       MOV     DPTR,#KEY_NET_ISR_FLAG
   \   000047   7400         MOV     A,#0x0
   \   000049   F0           MOVX    @DPTR,A
    424          	 }
    425               
    426               KEY_NET_ISR_FLAG++;//test 测试单击 双击等程序
   \                     ??HalKeyPoll_4:
   \   00004A   90....       MOV     DPTR,#KEY_NET_ISR_FLAG
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   2401         ADD     A,#0x1
   \   000050   F0           MOVX    @DPTR,A
    427               osal_stop_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT);//  停止之前进入的事件
   \   000051                ; Setup parameters for call to function osal_stop_timerEx
   \   000051   7A20         MOV     R2,#0x20
   \   000053   7B00         MOV     R3,#0x0
   \   000055   90....       MOV     DPTR,#Hal_TaskID
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F9           MOV     R1,A
   \   00005A   12....       LCALL   ??osal_stop_timerEx?relay
   \   00005D   E9           MOV     A,R1
    428               osal_start_timerEx (Hal_TaskID, HAL_KEY_MULTI_CLICK_EVENT, HAL_KEY_CLICKED_VALUE);//600mS后触发检测几击程序
   \   00005E                ; Setup parameters for call to function osal_start_timerEx
   \   00005E   7C58         MOV     R4,#0x58
   \   000060   7D02         MOV     R5,#0x2
   \   000062   7A20         MOV     R2,#0x20
   \   000064   7B00         MOV     R3,#0x0
   \   000066   90....       MOV     DPTR,#Hal_TaskID
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   F9           MOV     R1,A
   \   00006B   12....       LCALL   ??osal_start_timerEx?relay
   \   00006E   E9           MOV     A,R1
   \   00006F   8066         SJMP    ??HalKeyPoll_2
    429             } 
    430              
    431              // P0.6  对应第一个左边的按钮 灯为LED1 
    432             else if ((key_ISR_FLAG==HAL_KEY_SW_9) && (!HAL_PUSH_BUTTON5()))//初步理解，设置p1.5为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
   \                     ??HalKeyPoll_3:
   \   000071   90....       MOV     DPTR,#key_ISR_FLAG
   \   000074   E0           MOVX    A,@DPTR
   \   000075   6440         XRL     A,#0x40
   \   000077   702C         JNZ     ??HalKeyPoll_5
   \   000079   A290         MOV     C,0x90.0
   \   00007B   4028         JC      ??HalKeyPoll_5
    433             {
    434                 
    435                 key_press_zdo_flag = 1;//有按键按下
   \   00007D   90....       MOV     DPTR,#key_press_zdo_flag
   \   000080   7401         MOV     A,#0x1
   \   000082   F0           MOVX    @DPTR,A
    436                 screen_flag = 1;// 对应场景为2
   \   000083   90....       MOV     DPTR,#screen_flag
   \   000086   7401         MOV     A,#0x1
   \   000088   F0           MOVX    @DPTR,A
    437                if(devState == DEV_ROUTER)
   \   000089   90....       MOV     DPTR,#devState
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   6407         XRL     A,#0x7
   \   00008F   7046         JNZ     ??HalKeyPoll_2
    438               {
    439                    if(P1_7==1) //如果没有按下加网键
   \   000091   A297         MOV     C,0x90.7
   \   000093   5003         JNC     ??HalKeyPoll_6
    440                    SampleAPP_send_delay_message();
   \   000095                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   000095   12....       LCALL   ??SampleAPP_send_delay_message?relay
    441                    screen_flag = 0;
   \                     ??HalKeyPoll_6:
   \   000098   90....       MOV     DPTR,#screen_flag
   \   00009B   7400         MOV     A,#0x0
   \   00009D   F0           MOVX    @DPTR,A
    442            
    443                keys |= HAL_KEY_SW_9;
   \   00009E   D3           SETB    C
   \   00009F   EE           MOV     A,R6
   \   0000A0   92E6         MOV     0xE0 /* A   */.6,C
   \   0000A2   FE           MOV     R6,A
   \   0000A3   8032         SJMP    ??HalKeyPoll_2
    444               }
    445             }
    446             
    447             // P0.4 对应中间的按钮 指示灯也是中间的 
    448            else  if ((key_ISR_FLAG==HAL_KEY_SW_7) && (!HAL_PUSH_BUTTON2()))//初步理解，设置p1.5为上升沿触发，触发唤醒系统后，25ms到这，判断是否为1，是1则读取见键值
   \                     ??HalKeyPoll_5:
   \   0000A5   90....       MOV     DPTR,#key_ISR_FLAG
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   6410         XRL     A,#0x10
   \   0000AB   702A         JNZ     ??HalKeyPoll_2
   \   0000AD   A292         MOV     C,0x90.2
   \   0000AF   4026         JC      ??HalKeyPoll_2
    449             {
    450               
    451                 key_press_zdo_flag = 1;//有按键按下
   \   0000B1   90....       MOV     DPTR,#key_press_zdo_flag
   \   0000B4   7401         MOV     A,#0x1
   \   0000B6   F0           MOVX    @DPTR,A
    452                 screen_flag = 2;// 对应场景为2
   \   0000B7   90....       MOV     DPTR,#screen_flag
   \   0000BA   7402         MOV     A,#0x2
   \   0000BC   F0           MOVX    @DPTR,A
    453                if(devState == DEV_ROUTER)
   \   0000BD   90....       MOV     DPTR,#devState
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   6407         XRL     A,#0x7
   \   0000C3   7012         JNZ     ??HalKeyPoll_2
    454               {
    455                    if(P1_7==1) //如果没有按下加网键
   \   0000C5   A297         MOV     C,0x90.7
   \   0000C7   5003         JNC     ??HalKeyPoll_7
    456                    SampleAPP_send_delay_message();
   \   0000C9                ; Setup parameters for call to function SampleAPP_send_delay_message
   \   0000C9   12....       LCALL   ??SampleAPP_send_delay_message?relay
    457                    screen_flag = 0;
   \                     ??HalKeyPoll_7:
   \   0000CC   90....       MOV     DPTR,#screen_flag
   \   0000CF   7400         MOV     A,#0x0
   \   0000D1   F0           MOVX    @DPTR,A
    458               
    459                keys |= HAL_KEY_SW_7;
   \   0000D2   D3           SETB    C
   \   0000D3   EE           MOV     A,R6
   \   0000D4   92E4         MOV     0xE0 /* A   */.4,C
   \   0000D6   FE           MOV     R6,A
    460               }
    461             }
    462            }
    463           
    464            /* Invoke Callback if new keys were depressed */
    465            if (keys && (pHalKeyProcessFunction))
   \                     ??HalKeyPoll_2:
   \   0000D7   EE           MOV     A,R6
   \   0000D8   6024         JZ      ??HalKeyPoll_1
   \   0000DA   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   F8           MOV     R0,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   F9           MOV     R1,A
   \   0000E2   E8           MOV     A,R0
   \   0000E3   49           ORL     A,R1
   \   0000E4   6018         JZ      ??HalKeyPoll_1
    466            {
    467              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   0000E6                ; Setup parameters for indirect call
   \   0000E6   7A00         MOV     R2,#0x0
   \   0000E8   EE           MOV     A,R6
   \   0000E9   F9           MOV     R1,A
   \   0000EA   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   F8           MOV     R0,A
   \   0000EF   A3           INC     DPTR
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   F583         MOV     DPH,A
   \   0000F3   8882         MOV     DPL,R0
   \   0000F5   12....       LCALL   ?CALL_IND
    468              key_ISR_FLAG=0;
   \   0000F8   90....       MOV     DPTR,#key_ISR_FLAG
   \   0000FB   7400         MOV     A,#0x0
   \   0000FD   F0           MOVX    @DPTR,A
    469            }
    470          }
   \                     ??HalKeyPoll_1:
   \   0000FE   7F01         MOV     R7,#0x1
   \   000100   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000103                REQUIRE _A_P1
    471          
    472          
    473          
    474          
    475          /**************************************************************************************************
    476           * @fn      halGetJoyKeyInput
    477           *
    478           * @brief   Map the ADC value to its corresponding key.
    479           *
    480           * @param   None
    481           *
    482           * @return  keys - current joy key status
    483           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    485          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    486            /* The joystick control is encoded as an analog voltage.
    487             * Read the JOY_LEVEL analog value and map it to joy movement.
    488             */
    489            uint8 adc;
                         ^
Warning[Pe177]: variable "adc" was declared but never referenced
    490            uint8 ksave0 = 0;
   \   000000   7900         MOV     R1,#0x0
    491            uint8 ksave1;
                         ^
Warning[Pe177]: variable "ksave1" was declared but never referenced
    492          
    493          
    494          
    495            return ksave0;
   \   000002   02....       LJMP    ?BRET
    496          }
    497          
    498          
    499          
    500          
    501          
    502          /**************************************************************************************************
    503           * @fn      halProcessKeyInterrupt
    504           *
    505           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    506           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    507           *
    508           * @param
    509           *
    510           * @return
    511           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    512          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    513          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    514            bool valid=FALSE;
   \   000005   7E00         MOV     R6,#0x0
    515            
    516          
    517          
    518              if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)  /* Interrupt Flag has been set */
   \   000007   E58A         MOV     A,0x8a
   \   000009   A2E2         MOV     C,0xE0 /* A   */.2
   \   00000B   5005         JNC     ??halProcessKeyInterrupt_0
    519            {
    520              HAL_KEY_SW_7_PXIFG &= ~(HAL_KEY_SW_7_BIT); /* Clear Interrupt Flag */
   \   00000D   538AFB       ANL     0x8a,#0xfb
    521              valid = TRUE;
   \   000010   7E01         MOV     R6,#0x1
    522          
    523            }
    524            
    525              if (HAL_KEY_SW_8_PXIFG & HAL_KEY_SW_8_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_0:
   \   000012   E58A         MOV     A,0x8a
   \   000014   A2E7         MOV     C,0xE0 /* A   */.7
   \   000016   5005         JNC     ??halProcessKeyInterrupt_1
    526            {
    527              HAL_KEY_SW_8_PXIFG &= ~(HAL_KEY_SW_8_BIT); /* Clear Interrupt Flag */
   \   000018   538A7F       ANL     0x8a,#0x7f
    528              valid = TRUE;
   \   00001B   7E01         MOV     R6,#0x1
    529          
    530            }
    531            
    532              if (HAL_KEY_SW_9_PXIFG & HAL_KEY_SW_9_BIT)  /* Interrupt Flag has been set */
   \                     ??halProcessKeyInterrupt_1:
   \   00001D   E58A         MOV     A,0x8a
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   5005         JNC     ??halProcessKeyInterrupt_2
    533            {
    534              HAL_KEY_SW_9_PXIFG &= ~(HAL_KEY_SW_9_BIT); /* Clear Interrupt Flag */
   \   000023   538AFE       ANL     0x8a,#0xfe
    535              valid = TRUE;
   \   000026   7E01         MOV     R6,#0x1
    536          
    537           }
    538           
    539            if (valid)
   \                     ??halProcessKeyInterrupt_2:
   \   000028   EE           MOV     A,R6
   \   000029   6011         JZ      ??halProcessKeyInterrupt_3
    540           {
    541              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   00002B                ; Setup parameters for call to function osal_start_timerEx
   \   00002B   7C32         MOV     R4,#0x32
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   7A01         MOV     R2,#0x1
   \   000031   7B00         MOV     R3,#0x0
   \   000033   90....       MOV     DPTR,#Hal_TaskID
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   12....       LCALL   ??osal_start_timerEx?relay
   \   00003B   E9           MOV     A,R1
    542            }
    543          }
   \                     ??halProcessKeyInterrupt_3:
   \   00003C   7F01         MOV     R7,#0x1
   \   00003E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000041                REQUIRE P1IFG
    544          
    545          /**************************************************************************************************
    546           * @fn      HalKeyEnterSleep
    547           *
    548           * @brief  - Get called to enter sleep mode
    549           *
    550           * @param
    551           *
    552           * @return
    553           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    555          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    556          }
   \   000000   02....       LJMP    ?BRET
    557          
    558          /**************************************************************************************************
    559           * @fn      HalKeyExitSleep
    560           *
    561           * @brief   - Get called when sleep is over
    562           *
    563           * @param
    564           *
    565           * @return  - return saved keys
    566           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    567          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    568          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    569            /* Wake up and read keys */
    570            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    571          }
    572          
    573          /***************************************************************************************************
    574           *                                    INTERRUPT SERVICE ROUTINE
    575           ***************************************************************************************************/
    576          
    577          /**************************************************************************************************
    578           * @fn      halKeyPort0Isr
    579           *
    580           * @brief   Port0 ISR
    581           *
    582           * @param
    583           *
    584           * @return
    585           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    586          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    587          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007                ; Saved register size: 3
   \   000007                ; Auto size: 0
    588            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   F8           MOV     R0,A
   \   00000C   D2AF         SETB    0xa8.7
    589          
    590            ///uint8 P1IEN_FLAG_1=0,P1IEN_FLAG_2=0,P1IEN_FLAG_3=0;
    591          
    592             
    593          
    594            CLEAR_SLEEP_MODE();
    595            HAL_EXIT_ISR();
   \   00000E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000010   92AF         MOV     0xa8.7,C
    596          }
   \   000012   D0E0         POP     A
   \   000014   F8           MOV     R0,A
   \   000015   D0D0         POP     PSW
   \   000017   D0E0         POP     A
   \   000019   32           RETI
   \   00001A                REQUIRE _A_IEN0
    597          
    598          
    599          /**************************************************************************************************
    600           * @fn      halKeyPort1Isr
    601           *
    602           * @brief   Port1 ISR
    603           *
    604           * @param
    605           *
    606           * @return
    607           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    608          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
   \                     halKeyPort1Isr:
    609          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    610            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    611            //uint8 keys=0;
    612               if(HAL_KEY_SW_8_PXIFG & HAL_KEY_SW_8_BIT)//p1.7中断标志
   \   00000E   E58A         MOV     A,0x8a
   \   000010   A2E7         MOV     C,0xE0 /* A   */.7
   \   000012   5009         JNC     ??halKeyPort1Isr_0
    613            {
    614              
    615               halProcessKeyInterrupt();
   \   000014                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000014   12....       LCALL   ??halProcessKeyInterrupt?relay
    616               //HAL_KEY_SW_8_PXIFG = 0;//清除p1.2标志
    617               key_ISR_FLAG =HAL_KEY_SW_8;
   \   000017   90....       MOV     DPTR,#key_ISR_FLAG
   \   00001A   7480         MOV     A,#-0x80
   \   00001C   F0           MOVX    @DPTR,A
    618           
    619            }
    620              if (HAL_KEY_SW_7_PXIFG & HAL_KEY_SW_7_BIT)
   \                     ??halKeyPort1Isr_0:
   \   00001D   E58A         MOV     A,0x8a
   \   00001F   A2E2         MOV     C,0xE0 /* A   */.2
   \   000021   5009         JNC     ??halKeyPort1Isr_1
    621            {
    622              
    623               //P1IEN_FLAG_2 = P1IEN & 0X02;//p1.1
    624               //if(P1IEN_FLAG_2==0X02)
    625              //{
    626                halProcessKeyInterrupt();
   \   000023                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000023   12....       LCALL   ??halProcessKeyInterrupt?relay
    627                //HAL_KEY_SW_7_PXIFG = 0;
    628                key_ISR_FLAG =HAL_KEY_SW_7;
   \   000026   90....       MOV     DPTR,#key_ISR_FLAG
   \   000029   7410         MOV     A,#0x10
   \   00002B   F0           MOVX    @DPTR,A
    629              //}
    630            }
    631          
    632             if(HAL_KEY_SW_9_PXIFG & HAL_KEY_SW_9_BIT)//p1.2中断标志
   \                     ??halKeyPort1Isr_1:
   \   00002C   E58A         MOV     A,0x8a
   \   00002E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000030   5009         JNC     ??halKeyPort1Isr_2
    633            {
    634              
    635               //P1IEN_FLAG_3 = P1IEN & 0X04;//p1.2
    636               //if(P1IEN_FLAG_3==0X04)
    637              //{
    638               halProcessKeyInterrupt();
   \   000032                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000032   12....       LCALL   ??halProcessKeyInterrupt?relay
    639               //HAL_KEY_SW_9_PXIFG = 0;//清除p1.2标志
    640               key_ISR_FLAG =HAL_KEY_SW_9;
   \   000035   90....       MOV     DPTR,#key_ISR_FLAG
   \   000038   7440         MOV     A,#0x40
   \   00003A   F0           MOVX    @DPTR,A
    641              //}
    642           
    643            }
    644            
    645            
    646            /*
    647              Clear the CPU interrupt flag for Port_1
    648              PxIFG has to be cleared before PxIF
    649            */
    650            HAL_KEY_CPU_PORT_1_IF = 0;
   \                     ??halKeyPort1Isr_2:
   \   00003B   C2EB         CLR     0xe8.3
    651           // PCON = 0x00;//唤醒
    652            
    653            CLEAR_SLEEP_MODE();
    654            HAL_EXIT_ISR();
   \   00003D   EE           MOV     A,R6
   \   00003E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000040   92AF         MOV     0xa8.7,C
    655            
    656          }
   \   000042   7F01         MOV     R7,#0x1
   \   000044   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000047                REQUIRE _A_IEN0
   \   000047                REQUIRE P1IFG
   \   000047                REQUIRE _A_IRCON2
    657          
    658          
    659          
    660          
    661          /**************************************************************************************************
    662           * @fn      halKeyPort2Isr
    663           *
    664           * @brief   Port2 ISR
    665           *
    666           * @param
    667           *
    668           * @return
    669           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    670          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    671          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007                ; Saved register size: 3
   \   000007                ; Auto size: 0
    672            
    673            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   F8           MOV     R0,A
   \   00000C   D2AF         SETB    0xa8.7
    674            //uint8 keys=0;
    675          
    676            
    677            CLEAR_SLEEP_MODE();
    678            HAL_EXIT_ISR();  
   \   00000E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000010   92AF         MOV     0xa8.7,C
    679          }
   \   000012   D0E0         POP     A
   \   000014   F8           MOV     R0,A
   \   000015   D0D0         POP     PSW
   \   000017   D0E0         POP     A
   \   000019   32           RETI
   \   00001A                REQUIRE _A_IEN0

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment INTVEC, offset 0x7b, root
   \                     `??halKeyPort1Isr??INTVEC 123`:
   \   00007B   02....       LJMP       (halKeyPort1Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetJoyKeyInput?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
    680          
    681          #else
    682          
    683          void Key_Check(void){}
    684          void HalKeyInit(void){}
    685          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    686          uint8 HalKeyRead(void){ return 0;}
    687          void HalKeyPoll(void){}
    688          void HalKey_double_detect(void);
    689          #endif /* HAL_KEY */
    690          
    691          
    692          
    693          
    694          
    695          /**************************************************************************************************
    696          **************************************************************************************************/
    697          
    698          
    699          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     HalKeyConfig                       0      0      9
       -> osal_stop_timerEx             0      0     18
     HalKeyEnterSleep                   0      0      0
     HalKeyExitSleep                    2      0      0
       -> HalKeyRead                    4      0      0
     HalKeyInit                         2      0      0
     HalKeyPoll                         0      0      9
       -> osal_stop_timerEx             0      0     18
       -> osal_stop_timerEx             0      0     18
       -> osal_start_timerEx            0      0     18
       -> SampleAPP_send_delay_message
                                        0      0     18
       -> SampleAPP_send_delay_message
                                        0      0     18
     HalKeyRead                         0      0      0
     halGetJoyKeyInput                  0      0      0
     halKeyPort0Isr                     3      0      0
     halKeyPort1Isr                    15      0      0
       -> halProcessKeyInterrupt       30      0      0
       -> halProcessKeyInterrupt       30      0      0
       -> halProcessKeyInterrupt       30      0      0
     halKeyPort2Isr                     3      0      0
     halProcessKeyInterrupt             0      0      9
       -> osal_start_timerEx            0      0     18


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     P1IFG                             1
     PICTL                             1
     P1IEN                             1
     _A_P1                             1
     IEN2                              1
     _A_IEN0                           1
     _A_IRCON2                         1
     P1SEL                             1
     P1DIR                             1
     halKeySavedKeys                   1
     pHalKeyProcessFunction            2
     HalKeyConfigured                  1
     Hal_KeyIntEnable                  1
     kpush0                            1
     kpush1                            1
     key_ISR_FLAG                      1
     KEY_NET_ISR_FLAG                  1
     key_double_flag                   1
     key_holdtime_waiting_flag         1
     key_hold_flag                     1
     Forbitten_ON_flag                 1
     KEY_NUMBER_FLAG_A                 1
     key_press_zdo_flag                1
     HalKeyInit                       51
     HalKeyConfig                    108
     HalKeyRead                       14
     HalKeyPoll                      259
     halGetJoyKeyInput                 5
     halProcessKeyInterrupt           65
     HalKeyEnterSleep                  3
     HalKeyExitSleep                  14
     halKeyPort0Isr                   26
     halKeyPort1Isr                   71
     halKeyPort2Isr                   26
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??halKeyPort1Isr??INTVEC 123      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??halGetJoyKeyInput?relay         6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 519 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
 123 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
  15 bytes in segment XDATA_Z
 
 690 bytes of CODE  memory (+ 9 bytes shared)
   0 bytes of DATA  memory (+ 9 bytes shared)
  15 bytes of XDATA memory

Errors: none
Warnings: 2
